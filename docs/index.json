[{"content":"Giới thiệu Java Collections Framework cung cấp nhiều cấu trúc dữ liệu khác nhau, trong đó ArrayList và LinkedList là hai lựa chọn phổ biến nhất cho danh sách động.\nArrayList ArrayList sử dụng mảng động bên trong để lưu trữ phần tử:\nArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;Python\u0026#34;); list.add(\u0026#34;JavaScript\u0026#34;); Ưu điểm: Truy cập nhanh theo index O(1) Tiết kiệm bộ nhớ hơn Hiệu quả cho việc duyệt qua các phần tử Nhược điểm: Chèn/xóa phần tử ở giữa chậm O(n) Phải tái cấp phát bộ nhớ khi vượt quá capacity LinkedList LinkedList sử dụng cấu trúc danh sách liên kết đôi:\nLinkedList\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.addFirst(\u0026#34;Python\u0026#34;); list.addLast(\u0026#34;JavaScript\u0026#34;); Ưu điểm: Chèn/xóa phần tử nhanh O(1) khi biết vị trí Không cần tái cấp phát bộ nhớ Hỗ trợ thao tác đầu/cuối danh sách hiệu quả Nhược điểm: Truy cập theo index chậm O(n) Tốn bộ nhớ hơn (lưu trữ thêm con trỏ) Khi nào dùng gì? ArrayList: Khi cần truy cập ngẫu nhiên nhiều, ít thao tác chèn/xóa LinkedList: Khi thường xuyên chèn/xóa phần tử, ít truy cập theo index Kết luận Hiểu rõ đặc điểm của từng loại sẽ giúp bạn chọn đúng cấu trúc dữ liệu, tối ưu hiệu suất ứng dụng Java.\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/java-arraylist-vs-linkedlist/","tags":["Java","Data Structures"],"title":"Java Collections Framework: ArrayList vs LinkedList"},{"content":"Exception là gì? Exception là các sự kiện bất thường xảy ra trong quá trình chạy chương trình, làm gián đoạn luồng thực thi bình thường.\nPhân loại Exception 1. Checked Exception Phải được xử lý tại compile-time:\n// IOException là checked exception public void readFile(String path) throws IOException { FileReader file = new FileReader(path); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); reader.close(); } 2. Unchecked Exception Runtime exceptions, không bắt buộc phải xử lý:\n// NullPointerException, ArrayIndexOutOfBoundsException String text = null; text.length(); // NullPointerException Try-Catch-Finally Cú pháp cơ bản try { // Code có thể gây exception int result = 10 / 0; } catch (ArithmeticException e) { // Xử lý exception cụ thể System.out.println(\u0026#34;Không thể chia cho 0\u0026#34;); } catch (Exception e) { // Xử lý exception chung System.out.println(\u0026#34;Có lỗi xảy ra: \u0026#34; + e.getMessage()); } finally { // Luôn thực thi, dù có exception hay không System.out.println(\u0026#34;Clean up resources\u0026#34;); } Multi-catch (Java 7+) try { // Some code } catch (IOException | SQLException e) { // Xử lý cả 2 loại exception logger.error(\u0026#34;Database or IO error\u0026#34;, e); } Try-with-Resources (Java 7+) Tự động đóng resource:\n// Cách cũ BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;)); String line = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } // Try-with-resources (ngắn gọn hơn) try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;))) { String line = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } Tạo Custom Exception public class InsufficientFundsException extends Exception { private double amount; public InsufficientFundsException(double amount) { super(\u0026#34;Thiếu \u0026#34; + amount + \u0026#34; để thực hiện giao dịch\u0026#34;); this.amount = amount; } public double getAmount() { return amount; } } // Sử dụng public void withdraw(double amount) throws InsufficientFundsException { if (balance \u0026lt; amount) { throw new InsufficientFundsException(amount - balance); } balance -= amount; } Best Practices 1. Catch exception cụ thể nhất // ❌ Không tốt try { // code } catch (Exception e) { // Quá chung chung } // ✅ Tốt try { // code } catch (FileNotFoundException e) { // Xử lý cụ thể } catch (IOException e) { // Xử lý IO errors } 2. Không bỏ qua exception // ❌ Tệ nhất try { // code } catch (Exception e) { // Im lặng - rất nguy hiểm! } // ✅ Tốt try { // code } catch (Exception e) { logger.error(\u0026#34;Error occurred\u0026#34;, e); // hoặc throw lại } 3. Đóng resources // ✅ Sử dụng try-with-resources try (Connection conn = DriverManager.getConnection(url); PreparedStatement stmt = conn.prepareStatement(sql)) { // Use connection } catch (SQLException e) { logger.error(\u0026#34;Database error\u0026#34;, e); } 4. Exception message có ý nghĩa // ❌ Không rõ ràng throw new Exception(\u0026#34;Error\u0026#34;); // ✅ Rõ ràng throw new IllegalArgumentException( \u0026#34;User ID must be positive, got: \u0026#34; + userId ); 5. Không dùng exception cho flow control // ❌ Tệ try { while (true) { array[index++] = getData(); } } catch (ArrayIndexOutOfBoundsException e) { // Dùng exception để thoát vòng lặp } // ✅ Tốt while (index \u0026lt; array.length) { array[index++] = getData(); } Kết luận Exception handling đúng cách giúp ứng dụng robust, dễ debug và maintain. Hãy luôn xử lý exception một cách có ý nghĩa!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/java-exception-handling/","tags":["Java","Error Handling"],"title":"Java Exception Handling: Try-Catch và Best Practices"},{"content":"Vấn đề trước Generics Trước Java 5, collection không type-safe:\n// Trước Java 5 List list = new ArrayList(); list.add(\u0026#34;Hello\u0026#34;); list.add(123); list.add(new Date()); String text = (String) list.get(0); // OK String num = (String) list.get(1); // Runtime error! Generics giải quyết vấn đề // Với Generics List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Hello\u0026#34;); list.add(\u0026#34;World\u0026#34;); // list.add(123); // Compile error - Type safety! String text = list.get(0); // Không cần cast Generic Class Tạo Generic class public class Box\u0026lt;T\u0026gt; { private T value; public void set(T value) { this.value = value; } public T get() { return value; } } // Sử dụng Box\u0026lt;Integer\u0026gt; intBox = new Box\u0026lt;\u0026gt;(); intBox.set(123); int num = intBox.get(); // Không cần cast Box\u0026lt;String\u0026gt; strBox = new Box\u0026lt;\u0026gt;(); strBox.set(\u0026#34;Hello\u0026#34;); String text = strBox.get(); Multiple type parameters public class Pair\u0026lt;K, V\u0026gt; { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } // Sử dụng Pair\u0026lt;String, Integer\u0026gt; pair = new Pair\u0026lt;\u0026gt;(\u0026#34;Age\u0026#34;, 22); String key = pair.getKey(); Integer value = pair.getValue(); Generic Methods public class Utils { // Generic method public static \u0026lt;T\u0026gt; void printArray(T[] array) { for (T element : array) { System.out.println(element); } } // Multiple type parameters public static \u0026lt;K, V\u0026gt; void printPair(K key, V value) { System.out.println(key + \u0026#34;: \u0026#34; + value); } } // Sử dụng Integer[] intArray = {1, 2, 3}; String[] strArray = {\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;}; Utils.printArray(intArray); Utils.printArray(strArray); Utils.printPair(\u0026#34;Name\u0026#34;, \u0026#34;Bảo\u0026#34;); Bounded Type Parameters Upper bound // Chỉ chấp nhận Number và các subclass public class Calculator\u0026lt;T extends Number\u0026gt; { private T value; public Calculator(T value) { this.value = value; } public double getDoubleValue() { return value.doubleValue(); } } Calculator\u0026lt;Integer\u0026gt; intCalc = new Calculator\u0026lt;\u0026gt;(10); Calculator\u0026lt;Double\u0026gt; doubleCalc = new Calculator\u0026lt;\u0026gt;(10.5); // Calculator\u0026lt;String\u0026gt; strCalc = new Calculator\u0026lt;\u0026gt;(\u0026#34;10\u0026#34;); // Compile error! Multiple bounds interface Drawable { void draw(); } // T phải implement cả Comparable và Drawable public class Shape\u0026lt;T extends Comparable\u0026lt;T\u0026gt; \u0026amp; Drawable\u0026gt; { private T shape; public void compare(T other) { shape.compareTo(other); } public void display() { shape.draw(); } } Wildcards Unbounded wildcard (?) public static void printList(List\u0026lt;?\u0026gt; list) { for (Object element : list) { System.out.println(element); } } List\u0026lt;Integer\u0026gt; intList = Arrays.asList(1, 2, 3); List\u0026lt;String\u0026gt; strList = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); printList(intList); printList(strList); Upper bounded wildcard (? extends) // Chấp nhận List của Number hoặc subclass public static double sumList(List\u0026lt;? extends Number\u0026gt; list) { double sum = 0; for (Number num : list) { sum += num.doubleValue(); } return sum; } List\u0026lt;Integer\u0026gt; ints = Arrays.asList(1, 2, 3); List\u0026lt;Double\u0026gt; doubles = Arrays.asList(1.5, 2.5); System.out.println(sumList(ints)); // 6.0 System.out.println(sumList(doubles)); // 4.0 Lower bounded wildcard (? super) // Chấp nhận List của Integer hoặc superclass public static void addIntegers(List\u0026lt;? super Integer\u0026gt; list) { list.add(1); list.add(2); list.add(3); } List\u0026lt;Number\u0026gt; numbers = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); addIntegers(numbers); addIntegers(objects); PECS Principle Producer Extends, Consumer Super\n// Producer - dùng extends public static void copy( List\u0026lt;? extends Number\u0026gt; source, // Producer List\u0026lt;? super Number\u0026gt; dest // Consumer ) { for (Number num : source) { dest.add(num); } } Type Erasure Generics chỉ tồn tại ở compile-time, bị xóa ở runtime:\nList\u0026lt;String\u0026gt; strings = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; ints = new ArrayList\u0026lt;\u0026gt;(); // Runtime: cả 2 đều là ArrayList System.out.println(strings.getClass() == ints.getClass()); // true Best Practices Dùng generics thay vì raw types Dùng bounded types khi cần constraint Nhớ PECS principle khi dùng wildcards Tránh dùng generic arrays - có thể gây vấn đề Document type parameters rõ ràng /** * @param \u0026lt;T\u0026gt; the type of elements in this container * @param \u0026lt;K\u0026gt; the type of keys * @param \u0026lt;V\u0026gt; the type of values */ Kết luận Generics là công cụ mạnh mẽ giúp code type-safe, tái sử dụng được và ít lỗi runtime. Hiểu rõ generics là bước quan trọng để master Java!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/java-generics/","tags":["Java","Generics"],"title":"Java Generics: Type Safety cho Collection"},{"content":"Thread là gì? Thread là đơn vị nhỏ nhất của một process, cho phép chương trình thực hiện nhiều tác vụ đồng thời.\nTạo Thread trong Java Cách 1: Extends Thread class MyThread extends Thread { @Override public void run() { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } // Sử dụng MyThread thread1 = new MyThread(); MyThread thread2 = new MyThread(); thread1.start(); thread2.start(); Cách 2: Implements Runnable (Recommended) class MyTask implements Runnable { @Override public void run() { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } // Sử dụng Thread thread1 = new Thread(new MyTask()); Thread thread2 = new Thread(new MyTask()); thread1.start(); thread2.start(); Cách 3: Lambda Expression (Java 8+) Thread thread = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); thread.start(); Thread Lifecycle NEW → RUNNABLE → RUNNING → TERMINATED\r↓ ↓\rBLOCKED WAITING Thread Methods sleep() Thread.sleep(1000); // Sleep 1 giây join() Thread t1 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;Task 1\u0026#34;); }); t1.start(); t1.join(); // Chờ t1 hoàn thành System.out.println(\u0026#34;Task 1 completed\u0026#34;); interrupt() Thread thread = new Thread(() -\u0026gt; { try { while (!Thread.interrupted()) { System.out.println(\u0026#34;Working...\u0026#34;); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\u0026#34;Thread interrupted\u0026#34;); } }); thread.start(); Thread.sleep(3000); thread.interrupt(); // Ngắt thread Synchronization Vấn đề Race Condition class Counter { private int count = 0; public void increment() { count++; // Không thread-safe! } public int getCount() { return count; } } Giải pháp: synchronized class Counter { private int count = 0; public synchronized void increment() { count++; } public synchronized int getCount() { return count; } } Synchronized Block class Counter { private int count = 0; private Object lock = new Object(); public void increment() { synchronized(lock) { count++; } } } ExecutorService (Modern Approach) Thread Pool ExecutorService executor = Executors.newFixedThreadPool(3); for (int i = 0; i \u0026lt; 10; i++) { final int taskId = i; executor.submit(() -\u0026gt; { System.out.println(\u0026#34;Task \u0026#34; + taskId + \u0026#34; by \u0026#34; + Thread.currentThread().getName()); }); } executor.shutdown(); Callable \u0026amp; Future ExecutorService executor = Executors.newSingleThreadExecutor(); Callable\u0026lt;Integer\u0026gt; task = () -\u0026gt; { Thread.sleep(2000); return 42; }; Future\u0026lt;Integer\u0026gt; future = executor.submit(task); System.out.println(\u0026#34;Doing other work...\u0026#34;); Integer result = future.get(); // Block cho đến khi có kết quả System.out.println(\u0026#34;Result: \u0026#34; + result); executor.shutdown(); CompletableFuture (Java 8+) CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;Hello\u0026#34;; }); future.thenApply(result -\u0026gt; result + \u0026#34; World\u0026#34;) .thenAccept(System.out::println); Thread-Safe Collections // Synchronized collections List\u0026lt;String\u0026gt; syncList = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); Map\u0026lt;String, Integer\u0026gt; syncMap = Collections.synchronizedMap(new HashMap\u0026lt;\u0026gt;()); // Concurrent collections (Better performance) ConcurrentHashMap\u0026lt;String, Integer\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); CopyOnWriteArrayList\u0026lt;String\u0026gt; list = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); BlockingQueue\u0026lt;String\u0026gt; queue = new LinkedBlockingQueue\u0026lt;\u0026gt;(); Locks (java.util.concurrent.locks) ReentrantLock class Counter { private int count = 0; private Lock lock = new ReentrantLock(); public void increment() { lock.lock(); try { count++; } finally { lock.unlock(); // Luôn unlock trong finally } } } ReadWriteLock class Cache { private Map\u0026lt;String, String\u0026gt; data = new HashMap\u0026lt;\u0026gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); public String get(String key) { lock.readLock().lock(); try { return data.get(key); } finally { lock.readLock().unlock(); } } public void put(String key, String value) { lock.writeLock().lock(); try { data.put(key, value); } finally { lock.writeLock().unlock(); } } } Best Practices Dùng ExecutorService thay vì tạo Thread trực tiếp Tránh synchronized quá nhiều - ảnh hưởng performance Dùng concurrent collections khi cần thread-safety Luôn shutdown ExecutorService sau khi dùng Cẩn thận với deadlock - luôn lock theo thứ tự nhất quán Dùng ThreadLocal cho thread-specific data Test kỹ concurrent code - bugs khó reproduce Common Pitfalls Deadlock // ❌ Có thể bị deadlock synchronized(lock1) { synchronized(lock2) { // Critical section } } // Thread khác synchronized(lock2) { synchronized(lock1) { // Critical section } } Starting Thread trong Constructor // ❌ Nguy hiểm class MyClass extends Thread { public MyClass() { start(); // Có thể gây vấn đề } } Kết luận Multithreading giúp tận dụng tối đa CPU và cải thiện performance. Tuy nhiên, cần hiểu rõ về synchronization và concurrent programming để tránh bugs khó debug!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/java-multithreading/","tags":["Java","Concurrency"],"title":"Java Multithreading: Lập trình đa luồng cơ bản"},{"content":"Stream API là gì? Stream API (từ Java 8) cho phép xử lý collection theo phong cách functional programming:\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // Cách cũ int sum = 0; for (int num : numbers) { if (num % 2 == 0) { sum += num * 2; } } // Với Stream API int sum = numbers.stream() .filter(n -\u0026gt; n % 2 == 0) .map(n -\u0026gt; n * 2) .reduce(0, Integer::sum); Các thao tác phổ biến 1. Filter - Lọc phần tử List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;An\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;Chi\u0026#34;, \u0026#34;Dung\u0026#34;); List\u0026lt;String\u0026gt; filtered = names.stream() .filter(name -\u0026gt; name.length() \u0026gt; 2) .collect(Collectors.toList()); // Kết quả: [\u0026#34;Bình\u0026#34;, \u0026#34;Dung\u0026#34;] 2. Map - Biến đổi phần tử List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4); List\u0026lt;Integer\u0026gt; squared = numbers.stream() .map(n -\u0026gt; n * n) .collect(Collectors.toList()); // Kết quả: [1, 4, 9, 16] 3. Reduce - Tổng hợp kết quả List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .reduce(0, (a, b) -\u0026gt; a + b); // Kết quả: 15 Optional\u0026lt;Integer\u0026gt; max = numbers.stream() .reduce(Integer::max); 4. Collect - Thu thập kết quả List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;An\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;Chi\u0026#34;); // Thành List List\u0026lt;String\u0026gt; list = names.stream() .collect(Collectors.toList()); // Thành Set Set\u0026lt;String\u0026gt; set = names.stream() .collect(Collectors.toSet()); // Thành Map Map\u0026lt;String, Integer\u0026gt; map = names.stream() .collect(Collectors.toMap( name -\u0026gt; name, String::length )); Parallel Stream Xử lý song song để tăng hiệu suất:\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.parallelStream() .filter(n -\u0026gt; n % 2 == 0) .mapToInt(Integer::intValue) .sum(); Lưu ý quan trọng Stream chỉ dùng 1 lần: Không thể reuse stream đã xử lý Lazy evaluation: Chỉ thực thi khi gặp terminal operation Parallel không phải lúc nào cũng nhanh hơn: Chỉ hiệu quả với data lớn Kết luận Stream API giúp code ngắn gọn, dễ đọc và dễ maintain hơn nhiều so với vòng lặp truyền thống!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/java-stream-api/","tags":["Java","Stream API"],"title":"Java Stream API: Xử lý Collection hiện đại"},{"content":"Vấn đề với Callback Hell Trước đây, xử lý bất đồng bộ trong JavaScript rất khó đọc:\ngetData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); Promise giải quyết phần nào getData() .then(a =\u0026gt; getMoreData(a)) .then(b =\u0026gt; getMoreData(b)) .then(c =\u0026gt; getMoreData(c)) .then(d =\u0026gt; console.log(d)) .catch(error =\u0026gt; console.error(error)); Async/Await - Giải pháp tối ưu Async/await giúp code bất đồng bộ trông như đồng bộ:\nasync function fetchData() { try { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); console.log(d); } catch (error) { console.error(error); } } Cú pháp cơ bản Khai báo async function // Function declaration async function myFunction() { return \u0026#34;Hello\u0026#34;; } // Arrow function const myFunction = async () =\u0026gt; { return \u0026#34;Hello\u0026#34;; }; // Method class MyClass { async myMethod() { return \u0026#34;Hello\u0026#34;; } } Sử dụng await async function getUser() { const response = await fetch(\u0026#39;/api/user\u0026#39;); const data = await response.json(); return data; } Xử lý nhiều Promise song song ❌ Chậm - Chờ tuần tự async function getData() { const user = await fetchUser(); // 2s const posts = await fetchPosts(); // 2s const comments = await fetchComments(); // 2s // Tổng: 6s } ✅ Nhanh - Chạy song song async function getData() { const [user, posts, comments] = await Promise.all([ fetchUser(), fetchPosts(), fetchComments() ]); // Tổng: 2s (thời gian của request chậm nhất) } Error Handling Try/Catch async function fetchData() { try { const data = await fetch(\u0026#39;/api/data\u0026#39;); return data.json(); } catch (error) { console.error(\u0026#39;Lỗi:\u0026#39;, error); return null; } } Higher-order function const asyncHandler = (fn) =\u0026gt; async (req, res, next) =\u0026gt; { try { await fn(req, res, next); } catch (error) { next(error); } }; // Sử dụng app.get(\u0026#39;/users\u0026#39;, asyncHandler(async (req, res) =\u0026gt; { const users = await User.find(); res.json(users); })); Best Practices Luôn dùng try/catch hoặc .catch() để xử lý lỗi Chạy song song khi có thể với Promise.all() Không quên await - sẽ trở thành Promise chưa resolve Cẩn thận với forEach - dùng for...of thay vì forEach // ❌ Không hoạt động như mong đợi async function processArray(array) { array.forEach(async item =\u0026gt; { await processItem(item); }); } // ✅ Đúng cách async function processArray(array) { for (const item of array) { await processItem(item); } } Kết luận Async/await làm cho code bất đồng bộ dễ đọc, dễ debug và dễ maintain hơn rất nhiều so với callback và promise chains!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/javascript-async-await/","tags":["JavaScript","Async"],"title":"JavaScript Async/Await: Promise nhưng dễ đọc hơn"},{"content":"Closure là gì? Closure là một function có thể truy cập biến từ scope bên ngoài của nó, ngay cả sau khi function bên ngoài đã return.\nfunction outer() { const message = \u0026#39;Hello\u0026#39;; function inner() { console.log(message); // Truy cập được biến message } return inner; } const myFunc = outer(); myFunc(); // \u0026#39;Hello\u0026#39; - closure giữ reference đến message Tại sao Closures quan trọng? 1. Data Privacy / Encapsulation function createCounter() { let count = 0; // Private variable return { increment() { count++; return count; }, decrement() { count--; return count; }, getCount() { return count; } }; } const counter = createCounter(); console.log(counter.increment()); // 1 console.log(counter.increment()); // 2 console.log(counter.getCount()); // 2 // count không thể truy cập trực tiếp từ bên ngoài 2. Function Factories function createMultiplier(multiplier) { return function(number) { return number * multiplier; }; } const double = createMultiplier(2); const triple = createMultiplier(3); console.log(double(5)); // 10 console.log(triple(5)); // 15 3. Event Handlers function setupButton(buttonId, message) { const button = document.getElementById(buttonId); button.addEventListener(\u0026#39;click\u0026#39;, function() { // Closure giữ reference đến message alert(message); }); } setupButton(\u0026#39;btn1\u0026#39;, \u0026#39;Button 1 clicked!\u0026#39;); setupButton(\u0026#39;btn2\u0026#39;, \u0026#39;Button 2 clicked!\u0026#39;); Closure trong Loops - Vấn đề phổ biến ❌ Vấn đề với var for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 3, 3, 3 (không phải 0, 1, 2) }, 1000); } ✅ Giải pháp 1: IIFE for (var i = 0; i \u0026lt; 3; i++) { (function(j) { setTimeout(function() { console.log(j); // 0, 1, 2 }, 1000); })(i); } ✅ Giải pháp 2: let (ES6) for (let i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 0, 1, 2 }, 1000); } Use Cases thực tế 1. Module Pattern const Calculator = (function() { // Private variables let result = 0; // Private function function log(operation, value) { console.log(`${operation}: ${value}`); } // Public API return { add(num) { result += num; log(\u0026#39;Add\u0026#39;, num); return this; }, subtract(num) { result -= num; log(\u0026#39;Subtract\u0026#39;, num); return this; }, getResult() { return result; }, reset() { result = 0; return this; } }; })(); Calculator.add(10).subtract(3).add(5); console.log(Calculator.getResult()); // 12 2. Memoization (Caching) function memoize(fn) { const cache = {}; return function(...args) { const key = JSON.stringify(args); if (cache[key]) { console.log(\u0026#39;From cache\u0026#39;); return cache[key]; } console.log(\u0026#39;Calculating...\u0026#39;); const result = fn(...args); cache[key] = result; return result; }; } const fibonacci = memoize(function(n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); }); console.log(fibonacci(10)); // Calculating... console.log(fibonacci(10)); // From cache 3. Debounce function debounce(func, delay) { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() =\u0026gt; { func.apply(this, args); }, delay); }; } // Sử dụng const searchInput = document.getElementById(\u0026#39;search\u0026#39;); const handleSearch = debounce(function(event) { console.log(\u0026#39;Searching for:\u0026#39;, event.target.value); }, 500); searchInput.addEventListener(\u0026#39;input\u0026#39;, handleSearch); 4. Partial Application function partial(fn, ...fixedArgs) { return function(...remainingArgs) { return fn(...fixedArgs, ...remainingArgs); }; } function greet(greeting, name) { return `${greeting}, ${name}!`; } const sayHello = partial(greet, \u0026#39;Hello\u0026#39;); const sayHi = partial(greet, \u0026#39;Hi\u0026#39;); console.log(sayHello(\u0026#39;Bảo\u0026#39;)); // \u0026#39;Hello, Bảo!\u0026#39; console.log(sayHi(\u0026#39;An\u0026#39;)); // \u0026#39;Hi, An!\u0026#39; Memory Considerations Closures giữ reference đến outer scope, có thể gây memory leak nếu không cẩn thận:\n// ❌ Memory leak function setupButton() { const data = new Array(1000000).fill(\u0026#39;data\u0026#39;); document.getElementById(\u0026#39;btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Clicked\u0026#39;); // Closure giữ reference đến data dù không dùng }); } // ✅ Tốt hơn function setupButton() { const data = new Array(1000000).fill(\u0026#39;data\u0026#39;); const dataLength = data.length; // Chỉ giữ những gì cần document.getElementById(\u0026#39;btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Clicked, data length:\u0026#39;, dataLength); }); } Best Practices Chỉ closure những gì cần thiết - tránh giữ reference không cần Dùng let/const trong loops thay vì var Clean up event listeners để tránh memory leaks Document closure dependencies rõ ràng Kết luận Closures là một trong những khái niệm quan trọng nhất trong JavaScript. Hiểu rõ closures giúp bạn viết code mạnh mẽ, maintainable và tận dụng được sức mạnh của JavaScript!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/javascript-closures/","tags":["JavaScript","Advanced"],"title":"JavaScript Closures: Hiểu sâu về Scope và Memory"},{"content":"Destructuring là gì? Destructuring cho phép \u0026ldquo;giải nén\u0026rdquo; giá trị từ arrays hoặc properties từ objects thành các biến riêng biệt.\nArray Destructuring Cú pháp cơ bản // Cách cũ const arr = [1, 2, 3]; const first = arr[0]; const second = arr[1]; // Destructuring const [first, second, third] = [1, 2, 3]; console.log(first); // 1 console.log(second); // 2 console.log(third); // 3 Skip elements const [first, , third] = [1, 2, 3]; console.log(first); // 1 console.log(third); // 3 Default values const [a = 1, b = 2, c = 3] = [10, 20]; console.log(a); // 10 console.log(b); // 20 console.log(c); // 3 (default) Rest operator const [first, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(rest); // [2, 3, 4, 5] Swap variables let a = 1; let b = 2; // Không cần biến tạm [a, b] = [b, a]; console.log(a); // 2 console.log(b); // 1 Object Destructuring Cú pháp cơ bản const user = { name: \u0026#39;Bảo\u0026#39;, age: 22, email: \u0026#39;bao@example.com\u0026#39; }; // Cách cũ const name = user.name; const age = user.age; // Destructuring const { name, age, email } = user; console.log(name); // \u0026#39;Bảo\u0026#39; console.log(age); // 22 console.log(email); // \u0026#39;bao@example.com\u0026#39; Đổi tên biến const { name: userName, age: userAge } = user; console.log(userName); // \u0026#39;Bảo\u0026#39; console.log(userAge); // 22 Default values const { name, age, country = \u0026#39;Vietnam\u0026#39; } = user; console.log(country); // \u0026#39;Vietnam\u0026#39; Nested destructuring const user = { name: \u0026#39;Bảo\u0026#39;, address: { city: \u0026#39;TP.HCM\u0026#39;, district: \u0026#39;Quận 1\u0026#39; } }; const { name, address: { city, district } } = user; console.log(city); // \u0026#39;TP.HCM\u0026#39; console.log(district); // \u0026#39;Quận 1\u0026#39; Rest operator const user = { name: \u0026#39;Bảo\u0026#39;, age: 22, email: \u0026#39;bao@example.com\u0026#39;, phone: \u0026#39;0123456789\u0026#39; }; const { name, ...otherInfo } = user; console.log(name); // \u0026#39;Bảo\u0026#39; console.log(otherInfo); // { age: 22, email: \u0026#39;...\u0026#39;, phone: \u0026#39;...\u0026#39; } Use Cases thực tế 1. Function parameters // ❌ Khó nhớ thứ tự tham số function createUser(name, age, email, phone, address) { // ... } createUser(\u0026#39;Bảo\u0026#39;, 22, \u0026#39;bao@...\u0026#39;, \u0026#39;012...\u0026#39;, \u0026#39;TP.HCM\u0026#39;); // ✅ Dễ đọc hơn function createUser({ name, age, email, phone, address }) { // ... } createUser({ name: \u0026#39;Bảo\u0026#39;, email: \u0026#39;bao@...\u0026#39;, age: 22, phone: \u0026#39;012...\u0026#39;, address: \u0026#39;TP.HCM\u0026#39; }); 2. React props // Component với destructuring function UserCard({ name, age, avatar }) { return ( \u0026lt;div className=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;img src={avatar} alt={name} /\u0026gt; \u0026lt;h3\u0026gt;{name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{age} tuổi\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 3. API response async function getUser() { const response = await fetch(\u0026#39;/api/user\u0026#39;); const { data, status, message } = await response.json(); if (status === \u0026#39;success\u0026#39;) { return data; } throw new Error(message); } 4. Array methods const users = [ { id: 1, name: \u0026#39;An\u0026#39; }, { id: 2, name: \u0026#39;Bình\u0026#39; }, { id: 3, name: \u0026#39;Chi\u0026#39; } ]; // Destructuring trong map const names = users.map(({ name }) =\u0026gt; name); console.log(names); // [\u0026#39;An\u0026#39;, \u0026#39;Bình\u0026#39;, \u0026#39;Chi\u0026#39;] // Destructuring trong forEach users.forEach(({ id, name }) =\u0026gt; { console.log(`${id}: ${name}`); }); 5. Importing modules // Named imports sử dụng destructuring import { useState, useEffect } from \u0026#39;react\u0026#39;; import { sum, multiply } from \u0026#39;./utils\u0026#39;; // Rename khi import import { sum as add } from \u0026#39;./utils\u0026#39;; Best Practices Đặt default values để tránh undefined Đổi tên biến khi bị conflict Không destructure quá sâu - khó đọc Kết hợp với rest operator để lấy phần còn lại Kết luận Destructuring giúp code ngắn gọn, dễ đọc và dễ maintain hơn. Đây là một tính năng không thể thiếu trong JavaScript hiện đại!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/javascript-destructuring/","tags":["JavaScript","ES6"],"title":"JavaScript Destructuring: Giải nén dữ liệu dễ dàng"},{"content":"Arrow Functions là gì? Arrow Functions (hàm mũi tên) là cú pháp ngắn gọn để định nghĩa hàm trong ES6:\n// Cú pháp truyền thống const sum = function(a, b) { return a + b; }; // Arrow function const sum = (a, b) =\u0026gt; a + b; Đặc điểm nổi bật 1. Cú pháp ngắn gọn // Một tham số, không cần ngoặc đơn const square = x =\u0026gt; x * x; // Nhiều tham số const multiply = (a, b) =\u0026gt; a * b; // Nhiều dòng code, cần return const calculate = (a, b) =\u0026gt; { const sum = a + b; return sum * 2; }; 2. This Binding Arrow function không có this riêng, nó kế thừa this từ context bên ngoài:\nclass Counter { constructor() { this.count = 0; } // Arrow function - this trỏ đến Counter increment = () =\u0026gt; { this.count++; } // Regular function - this có thể bị thay đổi incrementOld() { this.count++; } } const counter = new Counter(); setTimeout(counter.increment, 1000); // OK setTimeout(counter.incrementOld, 1000); // Lỗi! Khi nào KHÔNG nên dùng Arrow Function? 1. Methods trong object // ❌ Không nên const obj = { value: 10, getValue: () =\u0026gt; this.value // undefined }; // ✅ Nên dùng const obj = { value: 10, getValue() { return this.value; } }; 2. Event handlers cần this của element // ❌ Không nên button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { this.classList.toggle(\u0026#39;active\u0026#39;); // this không phải button }); // ✅ Nên dùng button.addEventListener(\u0026#39;click\u0026#39;, function() { this.classList.toggle(\u0026#39;active\u0026#39;); }); Kết luận Arrow functions giúp code ngắn gọn và giải quyết vấn đề this binding trong nhiều trường hợp. Tuy nhiên, cần hiểu rõ cách hoạt động để sử dụng đúng lúc!\n","date":"2025-12-27T00:00:00Z","permalink":"http://localhost:1313/22DTHC5-6_BaoDG_MBT/posts/javascript-arrow-functions/","tags":["JavaScript","ES6"],"title":"JavaScript ES6+: Arrow Functions và This Binding"}]