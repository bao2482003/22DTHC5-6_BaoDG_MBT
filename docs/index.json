[{"content":"Generics không chỉ là một tính năng nâng cao trong Java mà còn là một công cụ mạnh mẽ giúp các lập trình viên xây dựng ứng dụng an toàn, hiệu quả và dễ dàng bảo trì. Với khả năng tổng quát hóa kiểu dữ liệu, Generics mở ra cơ hội giảm thiểu lỗi runtime và tối ưu hóa hiệu suất thông qua việc kiểm tra kiểu ngay tại thời điểm biên dịch. Nếu bạn muốn phát triển các ứng dụng Java hiện đại với chất lượng mã vượt trội, việc hiểu và làm chủ Generics là điều không thể thiếu. Trong bài viết này, chúng ta sẽ cùng khám phá cốt lõi của Generics, từ các khái niệm cơ bản cho đến cách áp dụng với những ví dụ đơn giản dễ hiểu, giúp bạn tự tin triển khai trong mọi dự án Java của mình.\nGeneric trong Java là gì? Generics là một tính năng trong Java (từ Java 5) cho phép bạn định nghĩa các lớp, phương thức, và giao diện với kiểu dữ liệu tổng quát. Điều này cung cấp sự kiểm soát kiểu mạnh mẽ, giảm lỗi tại runtime và tăng tính linh hoạt khi làm việc với dữ liệu.\nVí dụ không sử dụng Generic:\nList list = new ArrayList(); list.add(\u0026#34;Apple\u0026#34;); list.add(123); // Không bị kiểm tra kiểu String fruit = (String) list.get(1); // Gây lỗi ClassCastException List không được quy định kiểu dữ liệu (Raw Type), nên có thể thêm bất kỳ loại giá trị nào (String, Integer, \u0026hellip;). Khi lấy giá trị ra bằng list.get(1) và cố gắng ép kiểu sang String, giá trị thực là 123 (kiểu Integer) sẽ gây lỗi ClassCastException tại runtime. 2. Ví dụ có sử dụng Generic:\nList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Apple\u0026#34;); // list.add(123); // Lỗi compile-time String fruit = list.get(0); // An toàn và không cần ép kiểu Sử dụng Generics với List giới hạn chỉ cho phép thêm dữ liệu kiểu String vào danh sách. Nếu cố gắng thêm dữ liệu không hợp lệ (ví dụ 123), chương trình sẽ báo lỗi tại compile-time, ngăn ngừa lỗi trước khi chạy chương trình. Khi lấy dữ liệu bằng list.get(0), không cần ép kiểu thủ công, mã nguồn ngắn gọn và an toàn hơn. 2. Lợi ích của việc sử dụng Generics\nKiểm tra kiểu dữ liệu tại thời điểm biên dịch (Type Safety): Generics giúp đảm bảo rằng chỉ các kiểu dữ liệu hợp lệ được thêm vào cấu trúc dữ liệu, ngăn lỗi runtime do sai kiểu. Tham khảo ví dụ ở phần 1 để hiểu rõ hơn nhé mọi người. Giờ mình sang lợi ích thứ 2\nLoại bỏ việc ép kiểu thủ công (No Manual Casting) Generics tự động quản lý kiểu dữ liệu, không cần sử dụng (String), (Integer)\u0026hellip; thủ công khi truy xuất. // Không dùng Generics List list = new ArrayList(); list.add(\u0026#34;Generics\u0026#34;); String value = (String) list.get(0); // Phải ép kiểu thủ công // Có Generics List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Generics\u0026#34;); String value = list.get(0); // Không cần ép kiểu, an toàn và gọn gàng Generics tự động xác định kiểu dữ liệu, giúp mã rõ ràng và tránh sai sót do ép kiểu sai. 3. Tăng khả năng tái sử dụng mã nguồn (Code Reusability) Một lớp hoặc phương thức Generic có thể áp dụng cho bất kỳ kiểu dữ liệu nào, thay vì viết riêng cho từng kiểu.\n// Generic class class Box\u0026lt;T\u0026gt; { private T item; public void setItem(T item) { this.item = item; } public T getItem() { return item; } } public class Main { public static void main(String[] args) { Box\u0026lt;String\u0026gt; stringBox = new Box\u0026lt;\u0026gt;(); stringBox.setItem(\u0026#34;Hello Generics\u0026#34;); System.out.println(stringBox.getItem()); // Hello Generics Box\u0026lt;Integer\u0026gt; intBox = new Box\u0026lt;\u0026gt;(); intBox.setItem(123); System.out.println(intBox.getItem()); // 123 } } Box chỉ cần định nghĩa một lần, nhưng có thể sử dụng cho cả String, Integer, hay bất kỳ kiểu dữ liệu nào. 4. Dễ dàng bảo trì và đọc hiểu mã nguồn Generics làm cho mã nguồn dễ hiểu hơn, giúp xác định ngay kiểu dữ liệu được sử dụng và giảm lỗi logic.\n// Không dùng Generics Map map = new HashMap(); map.put(\u0026#34;key1\u0026#34;, 123); map.put(456, \u0026#34;value\u0026#34;); // Sai logic, nhưng không bị phát hiện // Có Generics Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, 123); // map.put(456, \u0026#34;value\u0026#34;); // Compile-time: Lỗi, đảm bảo đúng logic Generics giúp định nghĩa rõ ràng rằng Map\u0026lt;String, Integer\u0026gt; chỉ được phép sử dụng khóa là String và giá trị là Integer. 5. Hạn chế lỗi runtime (Reduced Runtime Errors) Bằng cách phát hiện lỗi tại compile-time, Generics loại bỏ nhiều lỗi runtime phổ biến như ClassCastException.\n// Không dùng Generics List list = new ArrayList(); list.add(10); list.add(\u0026#34;Java\u0026#34;); for (Object obj : list) { Integer value = (Integer) obj; // Gây lỗi runtime nếu obj là String System.out.println(value); } // Có Generics List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(10); // list.add(\u0026#34;Java\u0026#34;); // Compile-time: Lỗi for (Integer value : list) { System.out.println(value); // Không bao giờ lỗi runtime } Không dùng Generics: Chỉ phát hiện lỗi khi chạy chương trình. Có Generics: Lỗi sai kiểu bị ngăn chặn ngay tại compile-time. 3. Generic Classes Generic Class là lớp cho phép định nghĩa kiểu dữ liệu tổng quát (Generic) tại thời điểm khai báo. Với Generic Classes, bạn có thể viết mã linh hoạt, dễ tái sử dụng và đảm bảo tính an toàn kiểu.\nclass ClassName\u0026lt;T\u0026gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } T là một type parameter đại diện cho kiểu dữ liệu (ví dụ: String, Integer,\u0026hellip;). T có thể là bất kỳ ký tự nào, nhưng thường dùng: T, E, K, V. Ví dụ về Generic Class:\n// Định nghĩa Generic Class class Box\u0026lt;T\u0026gt; { private T item; public void setItem(T item) { this.item = item; } public T getItem() { return item; } } // Sử dụng Generic Class public class Main { public static void main(String[] args) { Box\u0026lt;String\u0026gt; stringBox = new Box\u0026lt;\u0026gt;(); stringBox.setItem(\u0026#34;Hello Generics\u0026#34;); System.out.println(\u0026#34;String Box: \u0026#34; + stringBox.getItem()); Box\u0026lt;Integer\u0026gt; integerBox = new Box\u0026lt;\u0026gt;(); integerBox.setItem(123); System.out.println(\u0026#34;Integer Box: \u0026#34; + integerBox.getItem()); } } Output:\nString Box: Hello Generics Integer Box: 123 Box chỉ nhận và xử lý dữ liệu kiểu String. Box chỉ nhận và xử lý dữ liệu kiểu Integer. Nhiều tham số kiểu (Multiple Type Parameters)\nBạn có thể dùng nhiều tham số kiểu trong một Generic Class.\nclass Pair\u0026lt;K, V\u0026gt; { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } Bounded Type Parameters\npublic class Main { public static void main(String[] args) { Pair\u0026lt;String, Integer\u0026gt; pair = new Pair\u0026lt;\u0026gt;(\u0026#34;Age\u0026#34;, 30); System.out.println(\u0026#34;Key: \u0026#34; + pair.getKey()); System.out.println(\u0026#34;Value: \u0026#34; + pair.getValue()); } } Output:\nKey: Age Value: 30 Bạn có thể giới hạn kiểu tham số của Generic Class bằng extends. Bounded Type Parameters\nBạn có thể giới hạn kiểu tham số của Generic Class bằng extends.\nclass NumberBox\u0026lt;T extends Number\u0026gt; { private T number; public void setNumber(T number) { this.number = number; } public T getNumber() { return number; } } public class Main { public static void main(String[] args) { NumberBox\u0026lt;Integer\u0026gt; intBox = new NumberBox\u0026lt;\u0026gt;(); intBox.setNumber(100); System.out.println(\u0026#34;Integer: \u0026#34; + intBox.getNumber()); NumberBox\u0026lt;Double\u0026gt; doubleBox = new NumberBox\u0026lt;\u0026gt;(); doubleBox.setNumber(10.5); System.out.println(\u0026#34;Double: \u0026#34; + doubleBox.getNumber()); // NumberBox\u0026lt;String\u0026gt; stringBox = new NumberBox\u0026lt;\u0026gt;(); // Lỗi compile-time } } Output:\nInteger: 100 Double: 10.5 giới hạn T chỉ có thể là Number hoặc các lớp con của Number như Integer, Double,\u0026hellip; 4. Generic Method Generic Method là phương thức cho phép sử dụng kiểu dữ liệu tổng quát (Generic) thay vì kiểu dữ liệu cố định. Kiểu dữ liệu tổng quát này được định nghĩa khi phương thức được gọi.\nCách khai báo Generic Method\npublic \u0026lt;T\u0026gt; ReturnType methodName(T parameter) { // Thân phương thức } : Khai báo một tham số kiểu dữ liệu tổng quát (Generic Type). T parameter: Sử dụng kiểu dữ liệu Generic làm tham số. ReturnType: Phương thức có thể trả về kiểu T hoặc các kiểu khác. Ví dụ:\npublic class GenericMethodExample { // Generic method public static \u0026lt;T\u0026gt; void printArray(T[] array) { for (T item : array) { System.out.println(item); } } public static void main(String[] args) { String[] stringArray = { \u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34; }; Integer[] intArray = { 1, 2, 3 }; // Gọi phương thức generic printArray(stringArray); printArray(intArray); } } Output:\nApple Banana Cherry 1 2 3 Phương thức printArray có thể in mọi kiểu dữ liệu (String, Integer,\u0026hellip;) nhờ sử dụng T. Phương thức generic với giá trị trả về\npublic class GenericReturnTypeExample { // Generic method public static \u0026lt;T\u0026gt; T getFirstElement(T[] array) { if (array.length \u0026gt; 0) { return array[0]; } return null; // Trả về null nếu mảng rỗng } public static void main(String[] args) { String[] stringArray = { \u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34; }; Integer[] intArray = { 10, 20, 30 }; System.out.println(\u0026#34;First string: \u0026#34; + getFirstElement(stringArray)); System.out.println(\u0026#34;First integer: \u0026#34; + getFirstElement(intArray)); } } Output:\nFirst string: Apple First integer: 10 Generic Method getFirstElement trả về giá trị kiểu dữ liệu của mảng được truyền vào. Bounded Type Parameters in Generic Method\nSử dụng từ khóa extends để giới hạn kiểu dữ liệu tổng quát.\npublic class BoundedGenericMethodExample { // Generic method với kiểu giới hạn public static \u0026lt;T extends Number\u0026gt; double sum(T a, T b) { return a.doubleValue() + b.doubleValue(); } public static void main(String[] args) { System.out.println(\u0026#34;Sum of 10 and 20: \u0026#34; + sum(10, 20)); System.out.println(\u0026#34;Sum of 3.5 and 4.5: \u0026#34; + sum(3.5, 4.5)); // sum(\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;); // Lỗi compile-time } } Output:\nSum of 10 and 20: 30.0 Sum of 3.5 and 4.5: 8.0 : Giới hạn kiểu T chỉ cho phép Number hoặc các lớp con (như Integer, Double). Generic Method trong lớp không Generic\nBạn có thể định nghĩa phương thức generic trong một lớp không generic.\npublic class NonGenericClass { // Phương thức generic trong lớp không generic public static \u0026lt;T\u0026gt; void printItem(T item) { System.out.println(\u0026#34;Item: \u0026#34; + item); } public static void main(String[] args) { printItem(\u0026#34;Hello\u0026#34;); printItem(123); } } Output:\nItem: Hello Item: 123 Wildcards trong Generic Method\nDùng wildcard ? để viết phương thức generic linh hoạt hơn.\nimport java.util.List; public class WildcardExample { // Sử dụng wildcard public static void printList(List\u0026lt;?\u0026gt; list) { for (Object item : list) { System.out.println(item); } } public static void main(String[] args) { List\u0026lt;String\u0026gt; stringList = List.of(\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;); List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); printList(stringList); printList(intList); } } Output:\nApple Banana 1 2 3 Wildcard ?: Cho phép sử dụng danh sách bất kỳ kiểu dữ liệu nào. 5. Wildcards (?) Trong Generics của Java, ký tự đại diện (Wildcard) ? được sử dụng để biểu thị một kiểu dữ liệu chưa biết. Nó giúp Generic trở nên linh hoạt hơn, đặc biệt khi làm việc với các loại dữ liệu không xác định chính xác.\nUnbounded Wildcard (?) Sử dụng khi kiểu dữ liệu có thể là bất kỳ loại nào. Cú pháp: ? import java.util.List; public class UnboundedWildcardExample { public static void printList(List\u0026lt;?\u0026gt; list) { for (Object item : list) { System.out.println(item); } } public static void main(String[] args) { List\u0026lt;String\u0026gt; stringList = List.of(\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;); List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); printList(stringList); printList(intList); } } Output:\nApple Banana 1 2 3 List\u003c?\u003e cho phép truyền vào bất kỳ kiểu nào. Trong thân phương thức, bạn chỉ có thể sử dụng các thao tác được hỗ trợ với Object vì không biết chính xác kiểu của danh sách. 2. Upper Bounded Wildcard (\u0026lt;? extends T\u0026gt;) Giới hạn kiểu dữ liệu là một lớp cụ thể hoặc các lớp con của nó. Cú pháp: \u0026lt;? extends T\u0026gt;\nimport java.util.List; public class UpperBoundedWildcardExample { public static double sumNumbers(List\u0026lt;? extends Number\u0026gt; list) { double sum = 0.0; for (Number num : list) { sum += num.doubleValue(); } return sum; } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; integers = List.of(1, 2, 3); List\u0026lt;Double\u0026gt; doubles = List.of(1.5, 2.5, 3.5); System.out.println(\u0026#34;Sum of integers: \u0026#34; + sumNumbers(integers)); System.out.println(\u0026#34;Sum of doubles: \u0026#34; + sumNumbers(doubles)); } } Output:\nSum of integers: 6.0 Sum of doubles: 7.5 \u003c? extends Number\u003e chỉ chấp nhận Number hoặc các lớp con như Integer, Double. Phương thức có thể làm việc với nhiều kiểu dữ liệu liên quan đến số. 3. Lower Bounded Wildcard (\u003c? super T\u003e) Giới hạn kiểu dữ liệu là một lớp cụ thể hoặc các lớp cha của nó. Cú pháp: \u003c? super T\u003e ```java import java.util.List; import java.util.ArrayList; public class LowerBoundedWildcardExample { public static void addNumbers(List\u003c? super Integer\u003e list) { list.add(10); list.add(20); } public static void main(String[] args) { List numbers = new ArrayList\u003c\u003e(); addNumbers(numbers); for (Object obj : numbers) { System.out.println(obj); } } } ``` **Output:** ``` 10 20 ``` \u003c? super Integer\u003e chỉ chấp nhận Integer hoặc các lớp cha như Number, Object. Có thể thêm các giá trị kiểu Integer vào danh sách. 4. Ứng dụng thực tế Khi nào dùng \u003c? extends T\u003e Khi đọc dữ liệu từ danh sách, nhưng không cần thêm mới. Ví dụ: Tính tổng các giá trị trong danh sách. Khi nào dùng \u003c? super T\u003e Khi thêm dữ liệu vào danh sách, nhưng không quan tâm đến kiểu cụ thể của danh sách. Ví dụ: Thêm các số vào danh sách cha (Number, Object). Khi nào dùng \u003c?\u003e Khi không cần biết hay kiểm soát kiểu dữ liệu cụ thể. Ví dụ: In danh sách bất kỳ. 5. Lưu ý khi sử dụng Wildcards Không thể thêm giá trị ngoài null khi dùng ? hoặc \u0026lt;? extends T\u0026gt;. Dùng ? khi làm việc với dữ liệu mà chỉ cần truy cập, không cần thay đổi. Wildcards làm mã tổng quát hơn, nhưng cũng có thể làm giảm an toàn kiểu nếu dùng không cẩn thận. Wildcards là công cụ mạnh mẽ để làm cho Generics linh hoạt và mạnh mẽ hơn trong Java 6. Các tham số kiểu trong Generics T (Type): Đại diện cho một kiểu bất kỳ. Dùng phổ biến trong các lớp, phương thức, hoặc interface tổng quát.\nE (Element): Đại diện cho phần tử. Thường sử dụng trong các cấu trúc dữ liệu như danh sách hoặc tập hợp.\nK (Key): Đại diện cho khóa trong cấu trúc cặp giá trị, ví dụ như Map.\nV (Value): Đại diện cho giá trị tương ứng với một khóa, sử dụng với cặp K-V.\nN (Number): Đại diện cho kiểu số như Integer, Double, hoặc Float.\n? (Wildcard): Đại diện cho một kiểu chưa biết, giúp làm việc với các đối tượng có kiểu không xác định cụ thể.\nBounded Type Parameters (Giới hạn kiểu):\n: Giới hạn T là Class hoặc các lớp con. : Giới hạn T là một interface cụ thể hoặc lớp triển khai interface đó. 7. Bảng So Sánh List, List, List, List\u003c?\u003e, List image.png\nKết bài Như vậy, chúng ta đã cùng nhau tìm hiểu về Generics trong Java, dù ban đầu việc làm quen với Generics có thể gây đôi chút khó khăn, nhưng với sự luyện tập và áp dụng thường xuyên, bạn sẽ thấy sự khác biệt rõ ràng trong cách quản lý kiểu dữ liệu và tối ưu hóa hiệu năng mã nguồn của mình. Hãy bắt đầu từ những ứng dụng nhỏ, từng bước triển khai Generics vào các bài toán thực tế, và biến chúng thành một phần không thể thiếu trong tư duy lập trình của bạn. Làm chủ Generics chính là một bước đi vững chắc để trở thành một lập trình viên Java chuyên nghiệp\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-generics/","tags":["Java","Generics"],"title":"Generics trong Java: Lợi ích và cách sử dụng tối ưu"},{"content":"Lập trình đa luồng luôn là một chủ đề được nhiều lập trình viên chú ý trong quá trình phát triển phần mềm, phải làm sao để chương trình của mình chạy trơn tru nhất, nhẹ nhàng nhất để người dùng có thiện cảm tốt với sản phẩm của mình. Trong bài viết dưới đây, chúng ta sẽ cùng tìm hiểu về lập trình đa luồng và các thực hiện với ngôn ngữ Java.\nĐa luồng là gì ? Thread(luồng) là một tiến trình con(sub-process), một đơn vị nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Đa tiến trình và đa luồng là các cách để đạt được đa nhiệm. Trong Java, các luồng được quản lý bởi máy ảo Java(JVM) Lợi ích của đa luồng Đa luồng không chặn người dùng vì các luồng là độc lập và bạn có thể thực hiện nhiều hành động tại một thời điểm\nCó thể tiết kiệm thời gian vì có thể thực hiện nhiều hành động đồng thời\nCác luồng độc lập nên nó sẽ không gây ảnh hưởng tới các luồng khác nếu exception xảy ra tại một luồng\nCác luồng có thể dùng chung và chia sẻ nguồn tài nguyên trong quá trình chạy, tuy nhiên các luồng vẫn sẽ hoạt động độc lập với nhau\nNhược điểm của đa luồng Xử lý chương trình phức tạp\nXử lý vấn đề tranh chấp bộ nhớ, đồng bộ dữ liệu khá phức tạp\nCần phát hiện các luồng bị chặn, block(dead lock) để tránh gây lỗi cho hệ thống\nĐa nhiệm là gì ? Đa nhiệm là khả năng chạy đồng thời một hay nhiều chương trình cùng lúc trên một hệ điều hành. Chúng ta dùng đa nhiệm để tối ưu việc sử dụng tài nguyên CPU. Đa nhiệm có thể đạt được qua hai cách: Đa nhiệm dựa trên đa tiến trình(Multiprocessing) Mỗi tiến trình có một địa chỉ trong bộ nhớ, mỗi tiến trình có một bộ nhớ riêng biệt\nMột tiến trình là nặng\nSự giao tiếp giữa các tiến trình có chi phí cao\nSự chuyển đổi giữa một tiến trình sang tiến trình khác đòi hỏi thời gian cho việc lưu và tải các vùng đăng ký bộ nhớ, danh sách, \u0026hellip;\nĐa nhiệm dựa trên đa luồng(Multithreading) Luồng sử dụng chung vùng nhớ\nLuồng là nhẹ\nChi phí giao tiếp giữa các luồng là không cao\nVòng đời của một Thread trong Java Một Thread sẽ trải qua năm trạng thái trong vòng đời của nó. Vòng đời của luồng được quản lý bởi JVM bao gồm có: NEW : Đây là trạng thái khi luồng vừa được khởi tạo bằng phương thức khởi tạo của lớp Thread nhưng chưa được start(). Ở trạng thái này, luồng được tạo ra nhưng chưa được cấp phát tài nguyên và cũng chưa chạy. Nếu luồng đang ở trạng thái này mà ta gọi các phương thức ép buộc stop,resume,suspend … sẽ là nguyên nhân sảy ra ngoại lệ IllegalThreadStateException .\nRUNNABLE : Sau khi gọi phương thức start() thì luồng test đã được cấp phát tài nguyên và các lịch điều phối CPU cho luồng test cũng bắt đầu có hiệu lực. Ở đây, chúng ta dùng trạng thái là Runnable chứ không phải Running, vì luồng không thực sự luôn chạy mà tùy vào hệ thống mà có sự điều phối CPU khác nhau.\nWAITING : Thread chờ không giới hạn cho đến khi một luồng khác đánh thức nó.\nTIMED_WAITING : Thread chờ trong một thời gian nhất định, hoặc là có một luồng khác đánh thức nó.\nBLOCKED: Đây là 1 dạng của trạng thái “Not Runnable”, là trạng thái khi Thread vẫn còn sống, nhưng hiện tại không được chọn để chạy. Thread chờ một monitor để unlock một đối tượng mà nó cần.\nTERMINATED : Một thread ở trong trạng thái terminated hoặc dead khi phương thức run() của nó bị thoát.\nLớp Thread trong Java Trong Java, chúng ta có thể tạo ra một luồng bằng cách tạo một đối tượng từ một lớp kế thừa lớp Thread. Để khởi tạo một luồng bằng cách này, chúng ta sẽ phải thực hiện các bước sau: Khai báo một lớp kế thừa lớp Thread\nOverride lại phương thức run() của lớp này, các dòng lệnh trong phương thức này sẽ được thực thi khi luồng bắt đầu chạy. Sau khi luồng đã thực hiện xong các dòng code trong phương thức run thì luồng sẽ chuyển sang trạng thái hủy.\nTạo một đối tượng của lớp vừa khai báo.\nGọi phương thức start() để bắt đầu thực thi luồng.\npublic class ThreadSample extends Thread{ @Override public void run() { System.out.println(\u0026#34;This is a thread, myThreadName: \u0026#34; + this.getName()); } } Tại sao gọi phương thức start() chứ không phải run() để thực thi luồng?\nPhương thức start() là phương thức đặc biệt được Oracle xây dựng trong lớp Thread, phương thức này sẽ cấp phát tài nguyên cho luồng rồi mới thực thi phương thức run() ở luồng này.\nDo đó, nếu ta gọi phương thức run() thì cũng tương đương với việc gọi một phương thức ở một lớp bình thường và nó sẽ chạy trên luồng thực hiện gọi phương thức chứ không sinh ra một luồng mới.\nThêm một lưu ý nữa, bạn không thể gọi phương thức start() của Thread hai lần, nếu không sẽ có ngoại lệ IllegalThreadStateException xảy ra.\nInterface Runnable trong Java Ngoài cách sử kế thừa lớp Thread trong Java, bạn hoàn toàn có thể sử dụng interface Runnable trong Java để khởi tạo một luồng mới. Để tạo luồng bằng cách sử dụng Runnable, ta phải làm các công việc sau: Khai báo một lớp implement Runnable\nOverride lại phương thức run() trong lớp này. Việc này tương tự với việc override lại phương thức run() trong cách sử dụng lớp Thread\nTạo một đối tượng của lớp vừa khai báo\nTạo một đối tượng Thread bằng constructor: Thread(Runnable runnable). Điều thú vị ở đây là, mặc dù chúng ta vẫn cần một đối tượng Thread để khởi tạo luồng mới, tuy nhiên thay vì việc override lại phương thức run() của nó thì chúng ta lại truyền vào đây một Runnable với các dòng code thực thi chương trình đã được thêm vào trong phương thức run()\nGọi phương thức start() để bắt đầu thực thi luồng\npublic class PingWorker implements Runnable { private static final Logger LOGGER = LogManager.getLogger(\u0026#34;PingWorker\u0026#34;); private static final long TIMEOUT_PING = 30 * 1000L; @Override public void run() { LOGGER.info(\u0026#34;Start ping worker !\u0026#34;); while (true) { Packet pingPacket = new Packet(); pingPacket.setServiceType(Constants.PacketServiceType.PING); pingPacket.setBody(new JSONObject()); List\u0026lt;Connection\u0026gt; allConnections = ConnectionManager.getInstance().getAllConnections(); for (Connection connection : allConnections) { connection.sendPacket(pingPacket); } try { TimeUnit.SECONDS.sleep(30); } catch (Exception ex) { LOGGER.error(\u0026#34;Error when trying to sleep \u0026#34;, ex); } } } } Khi nào thì nên dùng Runnable Vì Runnable là một interface nên nó có thể giúp chúng ta giải quyết bài toán đa kế thừa. Ngoài ra, Thread Pool cũng chấp nhận các đối tượng để nó quản lý là Runnable, việc sử dụng Thread Pool mang lại nhiều hiệu quả trong việc quản lý các luồng\nTrong các trường hợp còn lại, bạn hoàn toàn có thể sử dụng Thread\nVí dụ minh họa sử dụng đa luồng Tạo luồng với Thread public class ThreadSample extends Thread{ @Override public void run() { System.out.println(\u0026#34;This is a thread, myThreadName: \u0026#34; + this.getName()); } public static void main(String[] args) { ThreadSample thread = new ThreadSample(); ThreadSample thread2 = new ThreadSample(); ThreadSample thread3 = new ThreadSample(); System.out.println(\u0026#34;CurrentThread \u0026#34; + Thread.currentThread().getName()); thread.start(); thread2.start(); thread3.start(); } } Output chương trình:\nCurrentThread main\rThis is a thread, myThreadName: Thread-0\rThis is a thread, myThreadName: Thread-2\rThis is a thread, myThreadName: Thread-1 Tạo luồng với interface Runnable\npublic class RunnableSample implements Runnable { @Override public void run() { long timestamp = System.currentTimeMillis(); System.out.printf(\u0026#34;[%s]Checking timestamp%n\u0026#34;, Thread.currentThread().getName()); System.out.printf(\u0026#34;[%s]My timestamp: %d%n\u0026#34;, Thread.currentThread().getName(), timestamp); } public static void main(String[] args) { Thread thread1 = new Thread(new RunnableSample()); Thread thread2 = new Thread(new RunnableSample()); Thread thread3 = new Thread(new RunnableSample()); thread1.start(); thread2.start(); thread3.start(); } } Output chương trình:\n[Thread-2]Checking timestamp\r[Thread-0]Checking timestamp\r[Thread-0]My timestamp: 1687795285576\r[Thread-1]Checking timestamp\r[Thread-1]My timestamp: 1687795285576\r[Thread-2]My timestamp: 1687795285576 Các phương thức của lớp Thread thường được hay sử dụng Kiểu trả về Tên phương thức Mô tả void start() Được sử dụng để bắt đầu thực thi một luồng void run() Được sử dụng để chạy hành động của một luồng static void sleep() Nghỉ một luồng trong một khoảng thời gian static Thread currentThread() Trả về tham chiếu tới luồng đang thực thi đối tượng Thread void join() Chờ một thread hoàn thành vòng đời của nó int getPriority() Trả về giá trị ưu tiên của luồng void setPriority(int) Thay đổi giá trị ưu tiên của luồng String getName() Trả về tên của luồng void setName(String) Thay đổi tên của luồng long getId() Trả về id của luồng boolean isAlive() Cho biết thread còn sống hay không static void yield() Làm cho luồng hiện tại tạm dừng và cho phép các thread khác thực hiện trong một khoảng thời gian void suspend() Được sử dụng để tạm dừng một luồng void resume() Được sử dụng để tiếp tục luồng đã bị tạm dừng void stop() Được dùng để dừng thread void destroy() Dùng để phá hủy các nhóm luồng và các nhóm con của nó boolean isDaemon() Kiểm tra xem luồng này có phải là daemon thread hay không void setDaemon(boolean) Thay đổi việc luồng có phải là daemon hay không void interrupt() Làm gián đoạn một luồng trong java. Nếu thread nằm trong trạng thái sleep hoặc wait, nghĩa là sleep() hoặc wait() được gọi ra. Việc gọi phương thức interrupt() trên thread đó sẽ phá vỡ trạng thái sleep hoặc wait và ném ra ngoại lệ InterruptedException. Nếu thread không ở trong trạng thái sleep hoặc wait, việc gọi phương thức interrupt() thực hiện hành vi bình thường và không làm gián đoạn thread nhưng đặt cờ interrupt thành true. boolean isInterrupted() Kiểm tra xem luồng có bị interrupt hay không static boolean interrupted() Kiểm tra xem luồng hiện tại có bị interrupt hay chưa Kết luận\nLập trình đa luồng Java mang lại nhiều lợi ích như tăng hiệu suất và tận dụng tài nguyên hệ thống. Tuy nhiên, việc quản lý và đồng bộ hóa luồng đòi hỏi kỹ năng chính xác và phải tránh các vấn đề như data race và deadlock. Trong bài viết này, Stringee đã giúp các bạn có được các kiến thức về lập trình đa luồng với Java, trong các bài viết tiếp theo của series lập trình đa luồng, chúng ta sẽ tìm hiểu về cách phòng tránh deadlock và data race cũng như các kỹ thuật lập trình đa luồng khác.\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-multithreading/","tags":["Java","Concurrency"],"title":"Java: Lập Trình Đa Luồng Cơ Bản"},{"content":"Giới thiệu Java Collections Framework cung cấp nhiều cấu trúc dữ liệu khác nhau, trong đó ArrayList và LinkedList là hai lựa chọn phổ biến nhất cho danh sách động.\nArrayList ArrayList sử dụng mảng động bên trong để lưu trữ phần tử:\nArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;Python\u0026#34;); list.add(\u0026#34;JavaScript\u0026#34;); Ưu điểm: Truy cập nhanh theo index O(1) Tiết kiệm bộ nhớ hơn Hiệu quả cho việc duyệt qua các phần tử Nhược điểm: Chèn/xóa phần tử ở giữa chậm O(n) Phải tái cấp phát bộ nhớ khi vượt quá capacity LinkedList LinkedList sử dụng cấu trúc danh sách liên kết đôi:\nLinkedList\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.addFirst(\u0026#34;Python\u0026#34;); list.addLast(\u0026#34;JavaScript\u0026#34;); Ưu điểm: Chèn/xóa phần tử nhanh O(1) khi biết vị trí Không cần tái cấp phát bộ nhớ Hỗ trợ thao tác đầu/cuối danh sách hiệu quả Nhược điểm: Truy cập theo index chậm O(n) Tốn bộ nhớ hơn (lưu trữ thêm con trỏ) Khi nào dùng gì? ArrayList: Khi cần truy cập ngẫu nhiên nhiều, ít thao tác chèn/xóa LinkedList: Khi thường xuyên chèn/xóa phần tử, ít truy cập theo index Kết luận Hiểu rõ đặc điểm của từng loại sẽ giúp bạn chọn đúng cấu trúc dữ liệu, tối ưu hiệu suất ứng dụng Java.\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-arraylist-vs-linkedlist/","tags":["Java","Data Structures"],"title":"Java: So Sánh ArrayList và LinkedList"},{"content":"Stream API là gì? Stream API (từ Java 8) cho phép xử lý collection theo phong cách functional programming:\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // Cách cũ int sum = 0; for (int num : numbers) { if (num % 2 == 0) { sum += num * 2; } } // Với Stream API int sum = numbers.stream() .filter(n -\u0026gt; n % 2 == 0) .map(n -\u0026gt; n * 2) .reduce(0, Integer::sum); Các thao tác phổ biến 1. Filter - Lọc phần tử List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;An\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;Chi\u0026#34;, \u0026#34;Dung\u0026#34;); List\u0026lt;String\u0026gt; filtered = names.stream() .filter(name -\u0026gt; name.length() \u0026gt; 2) .collect(Collectors.toList()); // Kết quả: [\u0026#34;Bình\u0026#34;, \u0026#34;Dung\u0026#34;] 2. Map - Biến đổi phần tử List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4); List\u0026lt;Integer\u0026gt; squared = numbers.stream() .map(n -\u0026gt; n * n) .collect(Collectors.toList()); // Kết quả: [1, 4, 9, 16] 3. Reduce - Tổng hợp kết quả List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .reduce(0, (a, b) -\u0026gt; a + b); // Kết quả: 15 Optional\u0026lt;Integer\u0026gt; max = numbers.stream() .reduce(Integer::max); 4. Collect - Thu thập kết quả List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;An\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;Chi\u0026#34;); // Thành List List\u0026lt;String\u0026gt; list = names.stream() .collect(Collectors.toList()); // Thành Set Set\u0026lt;String\u0026gt; set = names.stream() .collect(Collectors.toSet()); // Thành Map Map\u0026lt;String, Integer\u0026gt; map = names.stream() .collect(Collectors.toMap( name -\u0026gt; name, String::length )); Parallel Stream Xử lý song song để tăng hiệu suất:\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.parallelStream() .filter(n -\u0026gt; n % 2 == 0) .mapToInt(Integer::intValue) .sum(); Lưu ý quan trọng Stream chỉ dùng 1 lần: Không thể reuse stream đã xử lý Lazy evaluation: Chỉ thực thi khi gặp terminal operation Parallel không phải lúc nào cũng nhanh hơn: Chỉ hiệu quả với data lớn Kết luận Stream API giúp code ngắn gọn, dễ đọc và dễ maintain hơn nhiều so với vòng lặp truyền thống!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-stream-api/","tags":["Java","Stream API"],"title":"Java: Stream API và Xử Lý Dữ Liệu"},{"content":"Exception là gì? Exception là các sự kiện bất thường xảy ra trong quá trình chạy chương trình, làm gián đoạn luồng thực thi bình thường.\nPhân loại Exception 1. Checked Exception Phải được xử lý tại compile-time:\n// IOException là checked exception public void readFile(String path) throws IOException { FileReader file = new FileReader(path); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); reader.close(); } 2. Unchecked Exception Runtime exceptions, không bắt buộc phải xử lý:\n// NullPointerException, ArrayIndexOutOfBoundsException String text = null; text.length(); // NullPointerException Try-Catch-Finally Cú pháp cơ bản try { // Code có thể gây exception int result = 10 / 0; } catch (ArithmeticException e) { // Xử lý exception cụ thể System.out.println(\u0026#34;Không thể chia cho 0\u0026#34;); } catch (Exception e) { // Xử lý exception chung System.out.println(\u0026#34;Có lỗi xảy ra: \u0026#34; + e.getMessage()); } finally { // Luôn thực thi, dù có exception hay không System.out.println(\u0026#34;Clean up resources\u0026#34;); } Multi-catch (Java 7+) try { // Some code } catch (IOException | SQLException e) { // Xử lý cả 2 loại exception logger.error(\u0026#34;Database or IO error\u0026#34;, e); } Try-with-Resources (Java 7+) Tự động đóng resource:\n// Cách cũ BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;)); String line = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } // Try-with-resources (ngắn gọn hơn) try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;))) { String line = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } Tạo Custom Exception public class InsufficientFundsException extends Exception { private double amount; public InsufficientFundsException(double amount) { super(\u0026#34;Thiếu \u0026#34; + amount + \u0026#34; để thực hiện giao dịch\u0026#34;); this.amount = amount; } public double getAmount() { return amount; } } // Sử dụng public void withdraw(double amount) throws InsufficientFundsException { if (balance \u0026lt; amount) { throw new InsufficientFundsException(amount - balance); } balance -= amount; } Best Practices 1. Catch exception cụ thể nhất // ❌ Không tốt try { // code } catch (Exception e) { // Quá chung chung } // ✅ Tốt try { // code } catch (FileNotFoundException e) { // Xử lý cụ thể } catch (IOException e) { // Xử lý IO errors } 2. Không bỏ qua exception // ❌ Tệ nhất try { // code } catch (Exception e) { // Im lặng - rất nguy hiểm! } // ✅ Tốt try { // code } catch (Exception e) { logger.error(\u0026#34;Error occurred\u0026#34;, e); // hoặc throw lại } 3. Đóng resources // ✅ Sử dụng try-with-resources try (Connection conn = DriverManager.getConnection(url); PreparedStatement stmt = conn.prepareStatement(sql)) { // Use connection } catch (SQLException e) { logger.error(\u0026#34;Database error\u0026#34;, e); } 4. Exception message có ý nghĩa // ❌ Không rõ ràng throw new Exception(\u0026#34;Error\u0026#34;); // ✅ Rõ ràng throw new IllegalArgumentException( \u0026#34;User ID must be positive, got: \u0026#34; + userId ); 5. Không dùng exception cho flow control // ❌ Tệ try { while (true) { array[index++] = getData(); } } catch (ArrayIndexOutOfBoundsException e) { // Dùng exception để thoát vòng lặp } // ✅ Tốt while (index \u0026lt; array.length) { array[index++] = getData(); } Kết luận Exception handling đúng cách giúp ứng dụng robust, dễ debug và maintain. Hãy luôn xử lý exception một cách có ý nghĩa!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-exception-handling/","tags":["Java","Error Handling"],"title":"Java: Xử Lý Ngoại Lệ với Try-Catch"},{"content":"Arrow Functions là gì? Arrow Functions (hàm mũi tên) là cú pháp ngắn gọn để định nghĩa hàm trong ES6:\n// Cú pháp truyền thống const sum = function(a, b) { return a + b; }; // Arrow function const sum = (a, b) =\u0026gt; a + b; Đặc điểm nổi bật 1. Cú pháp ngắn gọn // Một tham số, không cần ngoặc đơn const square = x =\u0026gt; x * x; // Nhiều tham số const multiply = (a, b) =\u0026gt; a * b; // Nhiều dòng code, cần return const calculate = (a, b) =\u0026gt; { const sum = a + b; return sum * 2; }; 2. This Binding Arrow function không có this riêng, nó kế thừa this từ context bên ngoài:\nclass Counter { constructor() { this.count = 0; } // Arrow function - this trỏ đến Counter increment = () =\u0026gt; { this.count++; } // Regular function - this có thể bị thay đổi incrementOld() { this.count++; } } const counter = new Counter(); setTimeout(counter.increment, 1000); // OK setTimeout(counter.incrementOld, 1000); // Lỗi! Khi nào KHÔNG nên dùng Arrow Function? 1. Methods trong object // ❌ Không nên const obj = { value: 10, getValue: () =\u0026gt; this.value // undefined }; // ✅ Nên dùng const obj = { value: 10, getValue() { return this.value; } }; 2. Event handlers cần this của element // ❌ Không nên button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { this.classList.toggle(\u0026#39;active\u0026#39;); // this không phải button }); // ✅ Nên dùng button.addEventListener(\u0026#39;click\u0026#39;, function() { this.classList.toggle(\u0026#39;active\u0026#39;); }); Kết luận Arrow functions giúp code ngắn gọn và giải quyết vấn đề this binding trong nhiều trường hợp. Tuy nhiên, cần hiểu rõ cách hoạt động để sử dụng đúng lúc!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-arrow-functions/","tags":["JavaScript","ES6"],"title":"JavaScript: Arrow Functions và This Binding"},{"content":"Vấn đề với Callback Hell Trước đây, xử lý bất đồng bộ trong JavaScript rất khó đọc:\ngetData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); Promise giải quyết phần nào getData() .then(a =\u0026gt; getMoreData(a)) .then(b =\u0026gt; getMoreData(b)) .then(c =\u0026gt; getMoreData(c)) .then(d =\u0026gt; console.log(d)) .catch(error =\u0026gt; console.error(error)); Async/Await - Giải pháp tối ưu Async/await giúp code bất đồng bộ trông như đồng bộ:\nasync function fetchData() { try { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); console.log(d); } catch (error) { console.error(error); } } Cú pháp cơ bản Khai báo async function // Function declaration async function myFunction() { return \u0026#34;Hello\u0026#34;; } // Arrow function const myFunction = async () =\u0026gt; { return \u0026#34;Hello\u0026#34;; }; // Method class MyClass { async myMethod() { return \u0026#34;Hello\u0026#34;; } } Sử dụng await async function getUser() { const response = await fetch(\u0026#39;/api/user\u0026#39;); const data = await response.json(); return data; } Xử lý nhiều Promise song song ❌ Chậm - Chờ tuần tự async function getData() { const user = await fetchUser(); // 2s const posts = await fetchPosts(); // 2s const comments = await fetchComments(); // 2s // Tổng: 6s } ✅ Nhanh - Chạy song song async function getData() { const [user, posts, comments] = await Promise.all([ fetchUser(), fetchPosts(), fetchComments() ]); // Tổng: 2s (thời gian của request chậm nhất) } Error Handling Try/Catch async function fetchData() { try { const data = await fetch(\u0026#39;/api/data\u0026#39;); return data.json(); } catch (error) { console.error(\u0026#39;Lỗi:\u0026#39;, error); return null; } } Higher-order function const asyncHandler = (fn) =\u0026gt; async (req, res, next) =\u0026gt; { try { await fn(req, res, next); } catch (error) { next(error); } }; // Sử dụng app.get(\u0026#39;/users\u0026#39;, asyncHandler(async (req, res) =\u0026gt; { const users = await User.find(); res.json(users); })); Best Practices Luôn dùng try/catch hoặc .catch() để xử lý lỗi Chạy song song khi có thể với Promise.all() Không quên await - sẽ trở thành Promise chưa resolve Cẩn thận với forEach - dùng for...of thay vì forEach // ❌ Không hoạt động như mong đợi async function processArray(array) { array.forEach(async item =\u0026gt; { await processItem(item); }); } // ✅ Đúng cách async function processArray(array) { for (const item of array) { await processItem(item); } } Kết luận Async/await làm cho code bất đồng bộ dễ đọc, dễ debug và dễ maintain hơn rất nhiều so với callback và promise chains!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-async-await/","tags":["JavaScript","Async"],"title":"JavaScript: Async/Await và Xử Lý Bất Đồng Bộ"},{"content":"Closure là gì? Closure là một function có thể truy cập biến từ scope bên ngoài của nó, ngay cả sau khi function bên ngoài đã return.\nfunction outer() { const message = \u0026#39;Hello\u0026#39;; function inner() { console.log(message); // Truy cập được biến message } return inner; } const myFunc = outer(); myFunc(); // \u0026#39;Hello\u0026#39; - closure giữ reference đến message Tại sao Closures quan trọng? 1. Data Privacy / Encapsulation function createCounter() { let count = 0; // Private variable return { increment() { count++; return count; }, decrement() { count--; return count; }, getCount() { return count; } }; } const counter = createCounter(); console.log(counter.increment()); // 1 console.log(counter.increment()); // 2 console.log(counter.getCount()); // 2 // count không thể truy cập trực tiếp từ bên ngoài 2. Function Factories function createMultiplier(multiplier) { return function(number) { return number * multiplier; }; } const double = createMultiplier(2); const triple = createMultiplier(3); console.log(double(5)); // 10 console.log(triple(5)); // 15 3. Event Handlers function setupButton(buttonId, message) { const button = document.getElementById(buttonId); button.addEventListener(\u0026#39;click\u0026#39;, function() { // Closure giữ reference đến message alert(message); }); } setupButton(\u0026#39;btn1\u0026#39;, \u0026#39;Button 1 clicked!\u0026#39;); setupButton(\u0026#39;btn2\u0026#39;, \u0026#39;Button 2 clicked!\u0026#39;); Closure trong Loops - Vấn đề phổ biến ❌ Vấn đề với var for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 3, 3, 3 (không phải 0, 1, 2) }, 1000); } ✅ Giải pháp 1: IIFE for (var i = 0; i \u0026lt; 3; i++) { (function(j) { setTimeout(function() { console.log(j); // 0, 1, 2 }, 1000); })(i); } ✅ Giải pháp 2: let (ES6) for (let i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 0, 1, 2 }, 1000); } Use Cases thực tế 1. Module Pattern const Calculator = (function() { // Private variables let result = 0; // Private function function log(operation, value) { console.log(`${operation}: ${value}`); } // Public API return { add(num) { result += num; log(\u0026#39;Add\u0026#39;, num); return this; }, subtract(num) { result -= num; log(\u0026#39;Subtract\u0026#39;, num); return this; }, getResult() { return result; }, reset() { result = 0; return this; } }; })(); Calculator.add(10).subtract(3).add(5); console.log(Calculator.getResult()); // 12 2. Memoization (Caching) function memoize(fn) { const cache = {}; return function(...args) { const key = JSON.stringify(args); if (cache[key]) { console.log(\u0026#39;From cache\u0026#39;); return cache[key]; } console.log(\u0026#39;Calculating...\u0026#39;); const result = fn(...args); cache[key] = result; return result; }; } const fibonacci = memoize(function(n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); }); console.log(fibonacci(10)); // Calculating... console.log(fibonacci(10)); // From cache 3. Debounce function debounce(func, delay) { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() =\u0026gt; { func.apply(this, args); }, delay); }; } // Sử dụng const searchInput = document.getElementById(\u0026#39;search\u0026#39;); const handleSearch = debounce(function(event) { console.log(\u0026#39;Searching for:\u0026#39;, event.target.value); }, 500); searchInput.addEventListener(\u0026#39;input\u0026#39;, handleSearch); 4. Partial Application function partial(fn, ...fixedArgs) { return function(...remainingArgs) { return fn(...fixedArgs, ...remainingArgs); }; } function greet(greeting, name) { return `${greeting}, ${name}!`; } const sayHello = partial(greet, \u0026#39;Hello\u0026#39;); const sayHi = partial(greet, \u0026#39;Hi\u0026#39;); console.log(sayHello(\u0026#39;Bảo\u0026#39;)); // \u0026#39;Hello, Bảo!\u0026#39; console.log(sayHi(\u0026#39;An\u0026#39;)); // \u0026#39;Hi, An!\u0026#39; Memory Considerations Closures giữ reference đến outer scope, có thể gây memory leak nếu không cẩn thận:\n// ❌ Memory leak function setupButton() { const data = new Array(1000000).fill(\u0026#39;data\u0026#39;); document.getElementById(\u0026#39;btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Clicked\u0026#39;); // Closure giữ reference đến data dù không dùng }); } // ✅ Tốt hơn function setupButton() { const data = new Array(1000000).fill(\u0026#39;data\u0026#39;); const dataLength = data.length; // Chỉ giữ những gì cần document.getElementById(\u0026#39;btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Clicked, data length:\u0026#39;, dataLength); }); } Best Practices Chỉ closure những gì cần thiết - tránh giữ reference không cần Dùng let/const trong loops thay vì var Clean up event listeners để tránh memory leaks Document closure dependencies rõ ràng Kết luận Closures là một trong những khái niệm quan trọng nhất trong JavaScript. Hiểu rõ closures giúp bạn viết code mạnh mẽ, maintainable và tận dụng được sức mạnh của JavaScript!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-closures/","tags":["JavaScript","Advanced"],"title":"JavaScript: Closures và Quản Lý Bộ Nhớ"},{"content":"Destructuring là gì? Destructuring cho phép \u0026ldquo;giải nén\u0026rdquo; giá trị từ arrays hoặc properties từ objects thành các biến riêng biệt.\nArray Destructuring Cú pháp cơ bản // Cách cũ const arr = [1, 2, 3]; const first = arr[0]; const second = arr[1]; // Destructuring const [first, second, third] = [1, 2, 3]; console.log(first); // 1 console.log(second); // 2 console.log(third); // 3 Skip elements const [first, , third] = [1, 2, 3]; console.log(first); // 1 console.log(third); // 3 Default values const [a = 1, b = 2, c = 3] = [10, 20]; console.log(a); // 10 console.log(b); // 20 console.log(c); // 3 (default) Rest operator const [first, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(rest); // [2, 3, 4, 5] Swap variables let a = 1; let b = 2; // Không cần biến tạm [a, b] = [b, a]; console.log(a); // 2 console.log(b); // 1 Object Destructuring Cú pháp cơ bản const user = { name: \u0026#39;Bảo\u0026#39;, age: 22, email: \u0026#39;bao@example.com\u0026#39; }; // Cách cũ const name = user.name; const age = user.age; // Destructuring const { name, age, email } = user; console.log(name); // \u0026#39;Bảo\u0026#39; console.log(age); // 22 console.log(email); // \u0026#39;bao@example.com\u0026#39; Đổi tên biến const { name: userName, age: userAge } = user; console.log(userName); // \u0026#39;Bảo\u0026#39; console.log(userAge); // 22 Default values const { name, age, country = \u0026#39;Vietnam\u0026#39; } = user; console.log(country); // \u0026#39;Vietnam\u0026#39; Nested destructuring const user = { name: \u0026#39;Bảo\u0026#39;, address: { city: \u0026#39;TP.HCM\u0026#39;, district: \u0026#39;Quận 1\u0026#39; } }; const { name, address: { city, district } } = user; console.log(city); // \u0026#39;TP.HCM\u0026#39; console.log(district); // \u0026#39;Quận 1\u0026#39; Rest operator const user = { name: \u0026#39;Bảo\u0026#39;, age: 22, email: \u0026#39;bao@example.com\u0026#39;, phone: \u0026#39;0123456789\u0026#39; }; const { name, ...otherInfo } = user; console.log(name); // \u0026#39;Bảo\u0026#39; console.log(otherInfo); // { age: 22, email: \u0026#39;...\u0026#39;, phone: \u0026#39;...\u0026#39; } Use Cases thực tế 1. Function parameters // ❌ Khó nhớ thứ tự tham số function createUser(name, age, email, phone, address) { // ... } createUser(\u0026#39;Bảo\u0026#39;, 22, \u0026#39;bao@...\u0026#39;, \u0026#39;012...\u0026#39;, \u0026#39;TP.HCM\u0026#39;); // ✅ Dễ đọc hơn function createUser({ name, age, email, phone, address }) { // ... } createUser({ name: \u0026#39;Bảo\u0026#39;, email: \u0026#39;bao@...\u0026#39;, age: 22, phone: \u0026#39;012...\u0026#39;, address: \u0026#39;TP.HCM\u0026#39; }); 2. React props // Component với destructuring function UserCard({ name, age, avatar }) { return ( \u0026lt;div className=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;img src={avatar} alt={name} /\u0026gt; \u0026lt;h3\u0026gt;{name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{age} tuổi\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 3. API response async function getUser() { const response = await fetch(\u0026#39;/api/user\u0026#39;); const { data, status, message } = await response.json(); if (status === \u0026#39;success\u0026#39;) { return data; } throw new Error(message); } 4. Array methods const users = [ { id: 1, name: \u0026#39;An\u0026#39; }, { id: 2, name: \u0026#39;Bình\u0026#39; }, { id: 3, name: \u0026#39;Chi\u0026#39; } ]; // Destructuring trong map const names = users.map(({ name }) =\u0026gt; name); console.log(names); // [\u0026#39;An\u0026#39;, \u0026#39;Bình\u0026#39;, \u0026#39;Chi\u0026#39;] // Destructuring trong forEach users.forEach(({ id, name }) =\u0026gt; { console.log(`${id}: ${name}`); }); 5. Importing modules // Named imports sử dụng destructuring import { useState, useEffect } from \u0026#39;react\u0026#39;; import { sum, multiply } from \u0026#39;./utils\u0026#39;; // Rename khi import import { sum as add } from \u0026#39;./utils\u0026#39;; Best Practices Đặt default values để tránh undefined Đổi tên biến khi bị conflict Không destructure quá sâu - khó đọc Kết hợp với rest operator để lấy phần còn lại Kết luận Destructuring giúp code ngắn gọn, dễ đọc và dễ maintain hơn. Đây là một tính năng không thể thiếu trong JavaScript hiện đại!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-destructuring/","tags":["JavaScript","ES6"],"title":"JavaScript: Destructuring và Giải Nén Dữ Liệu"}]