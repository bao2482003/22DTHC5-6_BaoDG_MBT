[{"content":"Thread là gì? Thread là đơn vị nhỏ nhất của một process, cho phép chương trình thực hiện nhiều tác vụ đồng thời.\nTạo Thread trong Java Cách 1: Extends Thread class MyThread extends Thread { @Override public void run() { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } // Sử dụng MyThread thread1 = new MyThread(); MyThread thread2 = new MyThread(); thread1.start(); thread2.start(); Cách 2: Implements Runnable (Recommended) class MyTask implements Runnable { @Override public void run() { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } // Sử dụng Thread thread1 = new Thread(new MyTask()); Thread thread2 = new Thread(new MyTask()); thread1.start(); thread2.start(); Cách 3: Lambda Expression (Java 8+) Thread thread = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); thread.start(); Thread Lifecycle NEW → RUNNABLE → RUNNING → TERMINATED\r↓ ↓\rBLOCKED WAITING Thread Methods sleep() Thread.sleep(1000); // Sleep 1 giây join() Thread t1 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;Task 1\u0026#34;); }); t1.start(); t1.join(); // Chờ t1 hoàn thành System.out.println(\u0026#34;Task 1 completed\u0026#34;); interrupt() Thread thread = new Thread(() -\u0026gt; { try { while (!Thread.interrupted()) { System.out.println(\u0026#34;Working...\u0026#34;); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\u0026#34;Thread interrupted\u0026#34;); } }); thread.start(); Thread.sleep(3000); thread.interrupt(); // Ngắt thread Synchronization Vấn đề Race Condition class Counter { private int count = 0; public void increment() { count++; // Không thread-safe! } public int getCount() { return count; } } Giải pháp: synchronized class Counter { private int count = 0; public synchronized void increment() { count++; } public synchronized int getCount() { return count; } } Synchronized Block class Counter { private int count = 0; private Object lock = new Object(); public void increment() { synchronized(lock) { count++; } } } ExecutorService (Modern Approach) Thread Pool ExecutorService executor = Executors.newFixedThreadPool(3); for (int i = 0; i \u0026lt; 10; i++) { final int taskId = i; executor.submit(() -\u0026gt; { System.out.println(\u0026#34;Task \u0026#34; + taskId + \u0026#34; by \u0026#34; + Thread.currentThread().getName()); }); } executor.shutdown(); Callable \u0026amp; Future ExecutorService executor = Executors.newSingleThreadExecutor(); Callable\u0026lt;Integer\u0026gt; task = () -\u0026gt; { Thread.sleep(2000); return 42; }; Future\u0026lt;Integer\u0026gt; future = executor.submit(task); System.out.println(\u0026#34;Doing other work...\u0026#34;); Integer result = future.get(); // Block cho đến khi có kết quả System.out.println(\u0026#34;Result: \u0026#34; + result); executor.shutdown(); CompletableFuture (Java 8+) CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;Hello\u0026#34;; }); future.thenApply(result -\u0026gt; result + \u0026#34; World\u0026#34;) .thenAccept(System.out::println); Thread-Safe Collections // Synchronized collections List\u0026lt;String\u0026gt; syncList = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); Map\u0026lt;String, Integer\u0026gt; syncMap = Collections.synchronizedMap(new HashMap\u0026lt;\u0026gt;()); // Concurrent collections (Better performance) ConcurrentHashMap\u0026lt;String, Integer\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); CopyOnWriteArrayList\u0026lt;String\u0026gt; list = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); BlockingQueue\u0026lt;String\u0026gt; queue = new LinkedBlockingQueue\u0026lt;\u0026gt;(); Locks (java.util.concurrent.locks) ReentrantLock class Counter { private int count = 0; private Lock lock = new ReentrantLock(); public void increment() { lock.lock(); try { count++; } finally { lock.unlock(); // Luôn unlock trong finally } } } ReadWriteLock class Cache { private Map\u0026lt;String, String\u0026gt; data = new HashMap\u0026lt;\u0026gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); public String get(String key) { lock.readLock().lock(); try { return data.get(key); } finally { lock.readLock().unlock(); } } public void put(String key, String value) { lock.writeLock().lock(); try { data.put(key, value); } finally { lock.writeLock().unlock(); } } } Best Practices Dùng ExecutorService thay vì tạo Thread trực tiếp Tránh synchronized quá nhiều - ảnh hưởng performance Dùng concurrent collections khi cần thread-safety Luôn shutdown ExecutorService sau khi dùng Cẩn thận với deadlock - luôn lock theo thứ tự nhất quán Dùng ThreadLocal cho thread-specific data Test kỹ concurrent code - bugs khó reproduce Common Pitfalls Deadlock // ❌ Có thể bị deadlock synchronized(lock1) { synchronized(lock2) { // Critical section } } // Thread khác synchronized(lock2) { synchronized(lock1) { // Critical section } } Starting Thread trong Constructor // ❌ Nguy hiểm class MyClass extends Thread { public MyClass() { start(); // Có thể gây vấn đề } } Kết luận Multithreading giúp tận dụng tối đa CPU và cải thiện performance. Tuy nhiên, cần hiểu rõ về synchronization và concurrent programming để tránh bugs khó debug!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-multithreading/","tags":["Java","Concurrency"],"title":"Java: Lập Trình Đa Luồng Cơ Bản"},{"content":"Giới thiệu Java Collections Framework cung cấp nhiều cấu trúc dữ liệu khác nhau, trong đó ArrayList và LinkedList là hai lựa chọn phổ biến nhất cho danh sách động.\nArrayList ArrayList sử dụng mảng động bên trong để lưu trữ phần tử:\nArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;Python\u0026#34;); list.add(\u0026#34;JavaScript\u0026#34;); Ưu điểm: Truy cập nhanh theo index O(1) Tiết kiệm bộ nhớ hơn Hiệu quả cho việc duyệt qua các phần tử Nhược điểm: Chèn/xóa phần tử ở giữa chậm O(n) Phải tái cấp phát bộ nhớ khi vượt quá capacity LinkedList LinkedList sử dụng cấu trúc danh sách liên kết đôi:\nLinkedList\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.addFirst(\u0026#34;Python\u0026#34;); list.addLast(\u0026#34;JavaScript\u0026#34;); Ưu điểm: Chèn/xóa phần tử nhanh O(1) khi biết vị trí Không cần tái cấp phát bộ nhớ Hỗ trợ thao tác đầu/cuối danh sách hiệu quả Nhược điểm: Truy cập theo index chậm O(n) Tốn bộ nhớ hơn (lưu trữ thêm con trỏ) Khi nào dùng gì? ArrayList: Khi cần truy cập ngẫu nhiên nhiều, ít thao tác chèn/xóa LinkedList: Khi thường xuyên chèn/xóa phần tử, ít truy cập theo index Kết luận Hiểu rõ đặc điểm của từng loại sẽ giúp bạn chọn đúng cấu trúc dữ liệu, tối ưu hiệu suất ứng dụng Java.\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-arraylist-vs-linkedlist/","tags":["Java","Data Structures"],"title":"Java: So Sánh ArrayList và LinkedList"},{"content":"Stream API là gì? Stream API (từ Java 8) cho phép xử lý collection theo phong cách functional programming:\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // Cách cũ int sum = 0; for (int num : numbers) { if (num % 2 == 0) { sum += num * 2; } } // Với Stream API int sum = numbers.stream() .filter(n -\u0026gt; n % 2 == 0) .map(n -\u0026gt; n * 2) .reduce(0, Integer::sum); Các thao tác phổ biến 1. Filter - Lọc phần tử List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;An\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;Chi\u0026#34;, \u0026#34;Dung\u0026#34;); List\u0026lt;String\u0026gt; filtered = names.stream() .filter(name -\u0026gt; name.length() \u0026gt; 2) .collect(Collectors.toList()); // Kết quả: [\u0026#34;Bình\u0026#34;, \u0026#34;Dung\u0026#34;] 2. Map - Biến đổi phần tử List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4); List\u0026lt;Integer\u0026gt; squared = numbers.stream() .map(n -\u0026gt; n * n) .collect(Collectors.toList()); // Kết quả: [1, 4, 9, 16] 3. Reduce - Tổng hợp kết quả List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .reduce(0, (a, b) -\u0026gt; a + b); // Kết quả: 15 Optional\u0026lt;Integer\u0026gt; max = numbers.stream() .reduce(Integer::max); 4. Collect - Thu thập kết quả List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;An\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;Chi\u0026#34;); // Thành List List\u0026lt;String\u0026gt; list = names.stream() .collect(Collectors.toList()); // Thành Set Set\u0026lt;String\u0026gt; set = names.stream() .collect(Collectors.toSet()); // Thành Map Map\u0026lt;String, Integer\u0026gt; map = names.stream() .collect(Collectors.toMap( name -\u0026gt; name, String::length )); Parallel Stream Xử lý song song để tăng hiệu suất:\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.parallelStream() .filter(n -\u0026gt; n % 2 == 0) .mapToInt(Integer::intValue) .sum(); Lưu ý quan trọng Stream chỉ dùng 1 lần: Không thể reuse stream đã xử lý Lazy evaluation: Chỉ thực thi khi gặp terminal operation Parallel không phải lúc nào cũng nhanh hơn: Chỉ hiệu quả với data lớn Kết luận Stream API giúp code ngắn gọn, dễ đọc và dễ maintain hơn nhiều so với vòng lặp truyền thống!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-stream-api/","tags":["Java","Stream API"],"title":"Java: Stream API và Xử Lý Dữ Liệu"},{"content":"Exception là gì? Exception là các sự kiện bất thường xảy ra trong quá trình chạy chương trình, làm gián đoạn luồng thực thi bình thường.\nPhân loại Exception 1. Checked Exception Phải được xử lý tại compile-time:\n// IOException là checked exception public void readFile(String path) throws IOException { FileReader file = new FileReader(path); BufferedReader reader = new BufferedReader(file); String line = reader.readLine(); reader.close(); } 2. Unchecked Exception Runtime exceptions, không bắt buộc phải xử lý:\n// NullPointerException, ArrayIndexOutOfBoundsException String text = null; text.length(); // NullPointerException Try-Catch-Finally Cú pháp cơ bản try { // Code có thể gây exception int result = 10 / 0; } catch (ArithmeticException e) { // Xử lý exception cụ thể System.out.println(\u0026#34;Không thể chia cho 0\u0026#34;); } catch (Exception e) { // Xử lý exception chung System.out.println(\u0026#34;Có lỗi xảy ra: \u0026#34; + e.getMessage()); } finally { // Luôn thực thi, dù có exception hay không System.out.println(\u0026#34;Clean up resources\u0026#34;); } Multi-catch (Java 7+) try { // Some code } catch (IOException | SQLException e) { // Xử lý cả 2 loại exception logger.error(\u0026#34;Database or IO error\u0026#34;, e); } Try-with-Resources (Java 7+) Tự động đóng resource:\n// Cách cũ BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;)); String line = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } // Try-with-resources (ngắn gọn hơn) try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;file.txt\u0026#34;))) { String line = reader.readLine(); } catch (IOException e) { e.printStackTrace(); } Tạo Custom Exception public class InsufficientFundsException extends Exception { private double amount; public InsufficientFundsException(double amount) { super(\u0026#34;Thiếu \u0026#34; + amount + \u0026#34; để thực hiện giao dịch\u0026#34;); this.amount = amount; } public double getAmount() { return amount; } } // Sử dụng public void withdraw(double amount) throws InsufficientFundsException { if (balance \u0026lt; amount) { throw new InsufficientFundsException(amount - balance); } balance -= amount; } Best Practices 1. Catch exception cụ thể nhất // ❌ Không tốt try { // code } catch (Exception e) { // Quá chung chung } // ✅ Tốt try { // code } catch (FileNotFoundException e) { // Xử lý cụ thể } catch (IOException e) { // Xử lý IO errors } 2. Không bỏ qua exception // ❌ Tệ nhất try { // code } catch (Exception e) { // Im lặng - rất nguy hiểm! } // ✅ Tốt try { // code } catch (Exception e) { logger.error(\u0026#34;Error occurred\u0026#34;, e); // hoặc throw lại } 3. Đóng resources // ✅ Sử dụng try-with-resources try (Connection conn = DriverManager.getConnection(url); PreparedStatement stmt = conn.prepareStatement(sql)) { // Use connection } catch (SQLException e) { logger.error(\u0026#34;Database error\u0026#34;, e); } 4. Exception message có ý nghĩa // ❌ Không rõ ràng throw new Exception(\u0026#34;Error\u0026#34;); // ✅ Rõ ràng throw new IllegalArgumentException( \u0026#34;User ID must be positive, got: \u0026#34; + userId ); 5. Không dùng exception cho flow control // ❌ Tệ try { while (true) { array[index++] = getData(); } } catch (ArrayIndexOutOfBoundsException e) { // Dùng exception để thoát vòng lặp } // ✅ Tốt while (index \u0026lt; array.length) { array[index++] = getData(); } Kết luận Exception handling đúng cách giúp ứng dụng robust, dễ debug và maintain. Hãy luôn xử lý exception một cách có ý nghĩa!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-exception-handling/","tags":["Java","Error Handling"],"title":"Java: Xử Lý Ngoại Lệ với Try-Catch"},{"content":"Arrow Functions là gì? Arrow Functions (hàm mũi tên) là cú pháp ngắn gọn để định nghĩa hàm trong ES6:\n// Cú pháp truyền thống const sum = function(a, b) { return a + b; }; // Arrow function const sum = (a, b) =\u0026gt; a + b; Đặc điểm nổi bật 1. Cú pháp ngắn gọn // Một tham số, không cần ngoặc đơn const square = x =\u0026gt; x * x; // Nhiều tham số const multiply = (a, b) =\u0026gt; a * b; // Nhiều dòng code, cần return const calculate = (a, b) =\u0026gt; { const sum = a + b; return sum * 2; }; 2. This Binding Arrow function không có this riêng, nó kế thừa this từ context bên ngoài:\nclass Counter { constructor() { this.count = 0; } // Arrow function - this trỏ đến Counter increment = () =\u0026gt; { this.count++; } // Regular function - this có thể bị thay đổi incrementOld() { this.count++; } } const counter = new Counter(); setTimeout(counter.increment, 1000); // OK setTimeout(counter.incrementOld, 1000); // Lỗi! Khi nào KHÔNG nên dùng Arrow Function? 1. Methods trong object // ❌ Không nên const obj = { value: 10, getValue: () =\u0026gt; this.value // undefined }; // ✅ Nên dùng const obj = { value: 10, getValue() { return this.value; } }; 2. Event handlers cần this của element // ❌ Không nên button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { this.classList.toggle(\u0026#39;active\u0026#39;); // this không phải button }); // ✅ Nên dùng button.addEventListener(\u0026#39;click\u0026#39;, function() { this.classList.toggle(\u0026#39;active\u0026#39;); }); Kết luận Arrow functions giúp code ngắn gọn và giải quyết vấn đề this binding trong nhiều trường hợp. Tuy nhiên, cần hiểu rõ cách hoạt động để sử dụng đúng lúc!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-arrow-functions/","tags":["JavaScript","ES6"],"title":"JavaScript: Arrow Functions và This Binding"},{"content":"Vấn đề với Callback Hell Trước đây, xử lý bất đồng bộ trong JavaScript rất khó đọc:\ngetData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); Promise giải quyết phần nào getData() .then(a =\u0026gt; getMoreData(a)) .then(b =\u0026gt; getMoreData(b)) .then(c =\u0026gt; getMoreData(c)) .then(d =\u0026gt; console.log(d)) .catch(error =\u0026gt; console.error(error)); Async/Await - Giải pháp tối ưu Async/await giúp code bất đồng bộ trông như đồng bộ:\nasync function fetchData() { try { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); console.log(d); } catch (error) { console.error(error); } } Cú pháp cơ bản Khai báo async function // Function declaration async function myFunction() { return \u0026#34;Hello\u0026#34;; } // Arrow function const myFunction = async () =\u0026gt; { return \u0026#34;Hello\u0026#34;; }; // Method class MyClass { async myMethod() { return \u0026#34;Hello\u0026#34;; } } Sử dụng await async function getUser() { const response = await fetch(\u0026#39;/api/user\u0026#39;); const data = await response.json(); return data; } Xử lý nhiều Promise song song ❌ Chậm - Chờ tuần tự async function getData() { const user = await fetchUser(); // 2s const posts = await fetchPosts(); // 2s const comments = await fetchComments(); // 2s // Tổng: 6s } ✅ Nhanh - Chạy song song async function getData() { const [user, posts, comments] = await Promise.all([ fetchUser(), fetchPosts(), fetchComments() ]); // Tổng: 2s (thời gian của request chậm nhất) } Error Handling Try/Catch async function fetchData() { try { const data = await fetch(\u0026#39;/api/data\u0026#39;); return data.json(); } catch (error) { console.error(\u0026#39;Lỗi:\u0026#39;, error); return null; } } Higher-order function const asyncHandler = (fn) =\u0026gt; async (req, res, next) =\u0026gt; { try { await fn(req, res, next); } catch (error) { next(error); } }; // Sử dụng app.get(\u0026#39;/users\u0026#39;, asyncHandler(async (req, res) =\u0026gt; { const users = await User.find(); res.json(users); })); Best Practices Luôn dùng try/catch hoặc .catch() để xử lý lỗi Chạy song song khi có thể với Promise.all() Không quên await - sẽ trở thành Promise chưa resolve Cẩn thận với forEach - dùng for...of thay vì forEach // ❌ Không hoạt động như mong đợi async function processArray(array) { array.forEach(async item =\u0026gt; { await processItem(item); }); } // ✅ Đúng cách async function processArray(array) { for (const item of array) { await processItem(item); } } Kết luận Async/await làm cho code bất đồng bộ dễ đọc, dễ debug và dễ maintain hơn rất nhiều so với callback và promise chains!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-async-await/","tags":["JavaScript","Async"],"title":"JavaScript: Async/Await và Xử Lý Bất Đồng Bộ"},{"content":"Closure là gì? Closure là một function có thể truy cập biến từ scope bên ngoài của nó, ngay cả sau khi function bên ngoài đã return.\nfunction outer() { const message = \u0026#39;Hello\u0026#39;; function inner() { console.log(message); // Truy cập được biến message } return inner; } const myFunc = outer(); myFunc(); // \u0026#39;Hello\u0026#39; - closure giữ reference đến message Tại sao Closures quan trọng? 1. Data Privacy / Encapsulation function createCounter() { let count = 0; // Private variable return { increment() { count++; return count; }, decrement() { count--; return count; }, getCount() { return count; } }; } const counter = createCounter(); console.log(counter.increment()); // 1 console.log(counter.increment()); // 2 console.log(counter.getCount()); // 2 // count không thể truy cập trực tiếp từ bên ngoài 2. Function Factories function createMultiplier(multiplier) { return function(number) { return number * multiplier; }; } const double = createMultiplier(2); const triple = createMultiplier(3); console.log(double(5)); // 10 console.log(triple(5)); // 15 3. Event Handlers function setupButton(buttonId, message) { const button = document.getElementById(buttonId); button.addEventListener(\u0026#39;click\u0026#39;, function() { // Closure giữ reference đến message alert(message); }); } setupButton(\u0026#39;btn1\u0026#39;, \u0026#39;Button 1 clicked!\u0026#39;); setupButton(\u0026#39;btn2\u0026#39;, \u0026#39;Button 2 clicked!\u0026#39;); Closure trong Loops - Vấn đề phổ biến ❌ Vấn đề với var for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 3, 3, 3 (không phải 0, 1, 2) }, 1000); } ✅ Giải pháp 1: IIFE for (var i = 0; i \u0026lt; 3; i++) { (function(j) { setTimeout(function() { console.log(j); // 0, 1, 2 }, 1000); })(i); } ✅ Giải pháp 2: let (ES6) for (let i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 0, 1, 2 }, 1000); } Use Cases thực tế 1. Module Pattern const Calculator = (function() { // Private variables let result = 0; // Private function function log(operation, value) { console.log(`${operation}: ${value}`); } // Public API return { add(num) { result += num; log(\u0026#39;Add\u0026#39;, num); return this; }, subtract(num) { result -= num; log(\u0026#39;Subtract\u0026#39;, num); return this; }, getResult() { return result; }, reset() { result = 0; return this; } }; })(); Calculator.add(10).subtract(3).add(5); console.log(Calculator.getResult()); // 12 2. Memoization (Caching) function memoize(fn) { const cache = {}; return function(...args) { const key = JSON.stringify(args); if (cache[key]) { console.log(\u0026#39;From cache\u0026#39;); return cache[key]; } console.log(\u0026#39;Calculating...\u0026#39;); const result = fn(...args); cache[key] = result; return result; }; } const fibonacci = memoize(function(n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); }); console.log(fibonacci(10)); // Calculating... console.log(fibonacci(10)); // From cache 3. Debounce function debounce(func, delay) { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() =\u0026gt; { func.apply(this, args); }, delay); }; } // Sử dụng const searchInput = document.getElementById(\u0026#39;search\u0026#39;); const handleSearch = debounce(function(event) { console.log(\u0026#39;Searching for:\u0026#39;, event.target.value); }, 500); searchInput.addEventListener(\u0026#39;input\u0026#39;, handleSearch); 4. Partial Application function partial(fn, ...fixedArgs) { return function(...remainingArgs) { return fn(...fixedArgs, ...remainingArgs); }; } function greet(greeting, name) { return `${greeting}, ${name}!`; } const sayHello = partial(greet, \u0026#39;Hello\u0026#39;); const sayHi = partial(greet, \u0026#39;Hi\u0026#39;); console.log(sayHello(\u0026#39;Bảo\u0026#39;)); // \u0026#39;Hello, Bảo!\u0026#39; console.log(sayHi(\u0026#39;An\u0026#39;)); // \u0026#39;Hi, An!\u0026#39; Memory Considerations Closures giữ reference đến outer scope, có thể gây memory leak nếu không cẩn thận:\n// ❌ Memory leak function setupButton() { const data = new Array(1000000).fill(\u0026#39;data\u0026#39;); document.getElementById(\u0026#39;btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Clicked\u0026#39;); // Closure giữ reference đến data dù không dùng }); } // ✅ Tốt hơn function setupButton() { const data = new Array(1000000).fill(\u0026#39;data\u0026#39;); const dataLength = data.length; // Chỉ giữ những gì cần document.getElementById(\u0026#39;btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Clicked, data length:\u0026#39;, dataLength); }); } Best Practices Chỉ closure những gì cần thiết - tránh giữ reference không cần Dùng let/const trong loops thay vì var Clean up event listeners để tránh memory leaks Document closure dependencies rõ ràng Kết luận Closures là một trong những khái niệm quan trọng nhất trong JavaScript. Hiểu rõ closures giúp bạn viết code mạnh mẽ, maintainable và tận dụng được sức mạnh của JavaScript!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-closures/","tags":["JavaScript","Advanced"],"title":"JavaScript: Closures và Quản Lý Bộ Nhớ"},{"content":"Destructuring là gì? Destructuring cho phép \u0026ldquo;giải nén\u0026rdquo; giá trị từ arrays hoặc properties từ objects thành các biến riêng biệt.\nArray Destructuring Cú pháp cơ bản // Cách cũ const arr = [1, 2, 3]; const first = arr[0]; const second = arr[1]; // Destructuring const [first, second, third] = [1, 2, 3]; console.log(first); // 1 console.log(second); // 2 console.log(third); // 3 Skip elements const [first, , third] = [1, 2, 3]; console.log(first); // 1 console.log(third); // 3 Default values const [a = 1, b = 2, c = 3] = [10, 20]; console.log(a); // 10 console.log(b); // 20 console.log(c); // 3 (default) Rest operator const [first, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(rest); // [2, 3, 4, 5] Swap variables let a = 1; let b = 2; // Không cần biến tạm [a, b] = [b, a]; console.log(a); // 2 console.log(b); // 1 Object Destructuring Cú pháp cơ bản const user = { name: \u0026#39;Bảo\u0026#39;, age: 22, email: \u0026#39;bao@example.com\u0026#39; }; // Cách cũ const name = user.name; const age = user.age; // Destructuring const { name, age, email } = user; console.log(name); // \u0026#39;Bảo\u0026#39; console.log(age); // 22 console.log(email); // \u0026#39;bao@example.com\u0026#39; Đổi tên biến const { name: userName, age: userAge } = user; console.log(userName); // \u0026#39;Bảo\u0026#39; console.log(userAge); // 22 Default values const { name, age, country = \u0026#39;Vietnam\u0026#39; } = user; console.log(country); // \u0026#39;Vietnam\u0026#39; Nested destructuring const user = { name: \u0026#39;Bảo\u0026#39;, address: { city: \u0026#39;TP.HCM\u0026#39;, district: \u0026#39;Quận 1\u0026#39; } }; const { name, address: { city, district } } = user; console.log(city); // \u0026#39;TP.HCM\u0026#39; console.log(district); // \u0026#39;Quận 1\u0026#39; Rest operator const user = { name: \u0026#39;Bảo\u0026#39;, age: 22, email: \u0026#39;bao@example.com\u0026#39;, phone: \u0026#39;0123456789\u0026#39; }; const { name, ...otherInfo } = user; console.log(name); // \u0026#39;Bảo\u0026#39; console.log(otherInfo); // { age: 22, email: \u0026#39;...\u0026#39;, phone: \u0026#39;...\u0026#39; } Use Cases thực tế 1. Function parameters // ❌ Khó nhớ thứ tự tham số function createUser(name, age, email, phone, address) { // ... } createUser(\u0026#39;Bảo\u0026#39;, 22, \u0026#39;bao@...\u0026#39;, \u0026#39;012...\u0026#39;, \u0026#39;TP.HCM\u0026#39;); // ✅ Dễ đọc hơn function createUser({ name, age, email, phone, address }) { // ... } createUser({ name: \u0026#39;Bảo\u0026#39;, email: \u0026#39;bao@...\u0026#39;, age: 22, phone: \u0026#39;012...\u0026#39;, address: \u0026#39;TP.HCM\u0026#39; }); 2. React props // Component với destructuring function UserCard({ name, age, avatar }) { return ( \u0026lt;div className=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;img src={avatar} alt={name} /\u0026gt; \u0026lt;h3\u0026gt;{name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{age} tuổi\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 3. API response async function getUser() { const response = await fetch(\u0026#39;/api/user\u0026#39;); const { data, status, message } = await response.json(); if (status === \u0026#39;success\u0026#39;) { return data; } throw new Error(message); } 4. Array methods const users = [ { id: 1, name: \u0026#39;An\u0026#39; }, { id: 2, name: \u0026#39;Bình\u0026#39; }, { id: 3, name: \u0026#39;Chi\u0026#39; } ]; // Destructuring trong map const names = users.map(({ name }) =\u0026gt; name); console.log(names); // [\u0026#39;An\u0026#39;, \u0026#39;Bình\u0026#39;, \u0026#39;Chi\u0026#39;] // Destructuring trong forEach users.forEach(({ id, name }) =\u0026gt; { console.log(`${id}: ${name}`); }); 5. Importing modules // Named imports sử dụng destructuring import { useState, useEffect } from \u0026#39;react\u0026#39;; import { sum, multiply } from \u0026#39;./utils\u0026#39;; // Rename khi import import { sum as add } from \u0026#39;./utils\u0026#39;; Best Practices Đặt default values để tránh undefined Đổi tên biến khi bị conflict Không destructure quá sâu - khó đọc Kết hợp với rest operator để lấy phần còn lại Kết luận Destructuring giúp code ngắn gọn, dễ đọc và dễ maintain hơn. Đây là một tính năng không thể thiếu trong JavaScript hiện đại!\n","date":"2025-12-27T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/javascript-destructuring/","tags":["JavaScript","ES6"],"title":"JavaScript: Destructuring và Giải Nén Dữ Liệu"},{"content":"Generics không chỉ là một tính năng nâng cao trong Java mà còn là một công cụ mạnh mẽ giúp các lập trình viên xây dựng ứng dụng an toàn, hiệu quả và dễ dàng bảo trì. Với khả năng tổng quát hóa kiểu dữ liệu, Generics mở ra cơ hội giảm thiểu lỗi runtime và tối ưu hóa hiệu suất thông qua việc kiểm tra kiểu ngay tại thời điểm biên dịch. Nếu bạn muốn phát triển các ứng dụng Java hiện đại với chất lượng mã vượt trội, việc hiểu và làm chủ Generics là điều không thể thiếu. Trong bài viết này, chúng ta sẽ cùng khám phá cốt lõi của Generics, từ các khái niệm cơ bản cho đến cách áp dụng với những ví dụ đơn giản dễ hiểu, giúp bạn tự tin triển khai trong mọi dự án Java của mình.\nimage.png\nGeneric trong Java là gì? Generics là một tính năng trong Java (từ Java 5) cho phép bạn định nghĩa các lớp, phương thức, và giao diện với kiểu dữ liệu tổng quát. Điều này cung cấp sự kiểm soát kiểu mạnh mẽ, giảm lỗi tại runtime và tăng tính linh hoạt khi làm việc với dữ liệu.\nVí dụ không sử dụng Generic:\nList list = new ArrayList();\nlist.add(\u0026ldquo;Apple\u0026rdquo;);\nlist.add(123); // Không bị kiểm tra kiểu\nString fruit = (String) list.get(1); // Gây lỗi ClassCastException\nList không được quy định kiểu dữ liệu (Raw Type), nên có thể thêm bất kỳ loại giá trị nào (String, Integer, \u0026hellip;). Khi lấy giá trị ra bằng list.get(1) và cố gắng ép kiểu sang String, giá trị thực là 123 (kiểu Integer) sẽ gây lỗi ClassCastException tại runtime. 2. Ví dụ có sử dụng Generic:\nList list = new ArrayList\u0026lt;\u0026gt;();\nlist.add(\u0026ldquo;Apple\u0026rdquo;);\n// list.add(123); // Lỗi compile-time\nString fruit = list.get(0); // An toàn và không cần ép kiểu\nSử dụng Generics với List giới hạn chỉ cho phép thêm dữ liệu kiểu String vào danh sách. Nếu cố gắng thêm dữ liệu không hợp lệ (ví dụ 123), chương trình sẽ báo lỗi tại compile-time, ngăn ngừa lỗi trước khi chạy chương trình. Khi lấy dữ liệu bằng list.get(0), không cần ép kiểu thủ công, mã nguồn ngắn gọn và an toàn hơn. 2. Lợi ích của việc sử dụng Generics\nKiểm tra kiểu dữ liệu tại thời điểm biên dịch (Type Safety): Generics giúp đảm bảo rằng chỉ các kiểu dữ liệu hợp lệ được thêm vào cấu trúc dữ liệu, ngăn lỗi runtime do sai kiểu. Tham khảo ví dụ ở phần 1 để hiểu rõ hơn nhé mọi người. Giờ mình sang lợi ích thứ 2\nLoại bỏ việc ép kiểu thủ công (No Manual Casting) Generics tự động quản lý kiểu dữ liệu, không cần sử dụng (String), (Integer)\u0026hellip; thủ công khi truy xuất. // Không dùng Generics List list = new ArrayList(); list.add(\u0026ldquo;Generics\u0026rdquo;); String value = (String) list.get(0); // Phải ép kiểu thủ công\n// Có Generics List list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026ldquo;Generics\u0026rdquo;); String value = list.get(0); // Không cần ép kiểu, an toàn và gọn gàng\nGenerics tự động xác định kiểu dữ liệu, giúp mã rõ ràng và tránh sai sót do ép kiểu sai. 3. Tăng khả năng tái sử dụng mã nguồn (Code Reusability) Một lớp hoặc phương thức Generic có thể áp dụng cho bất kỳ kiểu dữ liệu nào, thay vì viết riêng cho từng kiểu.\n// Generic class class Box { private T item; public void setItem(T item) { this.item = item; } public T getItem() { return item; } }\npublic class Main { public static void main(String[] args) { Box stringBox = new Box\u0026lt;\u0026gt;(); stringBox.setItem(\u0026ldquo;Hello Generics\u0026rdquo;); System.out.println(stringBox.getItem()); // Hello Generics\nBox\u0026lt;Integer\u0026gt; intBox = new Box\u0026lt;\u0026gt;(); intBox.setItem(123); System.out.println(intBox.getItem()); // 123 } }\nBox chỉ cần định nghĩa một lần, nhưng có thể sử dụng cho cả String, Integer, hay bất kỳ kiểu dữ liệu nào. 4. Dễ dàng bảo trì và đọc hiểu mã nguồn Generics làm cho mã nguồn dễ hiểu hơn, giúp xác định ngay kiểu dữ liệu được sử dụng và giảm lỗi logic.\n// Không dùng Generics Map map = new HashMap(); map.put(\u0026ldquo;key1\u0026rdquo;, 123); map.put(456, \u0026ldquo;value\u0026rdquo;); // Sai logic, nhưng không bị phát hiện\n// Có Generics Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026ldquo;key1\u0026rdquo;, 123); // map.put(456, \u0026ldquo;value\u0026rdquo;); // Compile-time: Lỗi, đảm bảo đúng logic\nGenerics giúp định nghĩa rõ ràng rằng Map\u0026lt;String, Integer\u0026gt; chỉ được phép sử dụng khóa là String và giá trị là Integer. 5. Hạn chế lỗi runtime (Reduced Runtime Errors) Bằng cách phát hiện lỗi tại compile-time, Generics loại bỏ nhiều lỗi runtime phổ biến như ClassCastException.\n// Không dùng Generics List list = new ArrayList(); list.add(10); list.add(\u0026ldquo;Java\u0026rdquo;); for (Object obj : list) { Integer value = (Integer) obj; // Gây lỗi runtime nếu obj là String System.out.println(value); }\n// Có Generics List list = new ArrayList\u0026lt;\u0026gt;(); list.add(10); // list.add(\u0026ldquo;Java\u0026rdquo;); // Compile-time: Lỗi for (Integer value : list) { System.out.println(value); // Không bao giờ lỗi runtime }\nKhông dùng Generics: Chỉ phát hiện lỗi khi chạy chương trình. Có Generics: Lỗi sai kiểu bị ngăn chặn ngay tại compile-time. 3. Generic Classes Generic Class là lớp cho phép định nghĩa kiểu dữ liệu tổng quát (Generic) tại thời điểm khai báo. Với Generic Classes, bạn có thể viết mã linh hoạt, dễ tái sử dụng và đảm bảo tính an toàn kiểu.\nclass ClassName { private T value;\npublic void setValue(T value) { this.value = value; } public T getValue() { return value; } }\nT là một type parameter đại diện cho kiểu dữ liệu (ví dụ: String, Integer,\u0026hellip;). T có thể là bất kỳ ký tự nào, nhưng thường dùng: T, E, K, V. Ví dụ về Generic Class:\n// Định nghĩa Generic Class class Box { private T item;\npublic void setItem(T item) { this.item = item; } public T getItem() { return item; } }\n// Sử dụng Generic Class public class Main { public static void main(String[] args) { Box stringBox = new Box\u0026lt;\u0026gt;(); stringBox.setItem(\u0026ldquo;Hello Generics\u0026rdquo;); System.out.println(\u0026ldquo;String Box: \u0026quot; + stringBox.getItem());\nBox\u0026lt;Integer\u0026gt; integerBox = new Box\u0026lt;\u0026gt;(); integerBox.setItem(123); System.out.println(\u0026quot;Integer Box: \u0026quot; + integerBox.getItem()); } }\nString Box: Hello Generics Integer Box: 123\nBox chỉ nhận và xử lý dữ liệu kiểu String. Box chỉ nhận và xử lý dữ liệu kiểu Integer. Nhiều tham số kiểu (Multiple Type Parameters)\nBạn có thể dùng nhiều tham số kiểu trong một Generic Class.\nclass Pair\u0026lt;K, V\u0026gt; { private K key; private V value;\npublic Pair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } }\nBounded Type Parameters\npublic class Main { public static void main(String[] args) { Pair\u0026lt;String, Integer\u0026gt; pair = new Pair\u0026lt;\u0026gt;(\u0026ldquo;Age\u0026rdquo;, 30); System.out.println(\u0026ldquo;Key: \u0026quot; + pair.getKey()); System.out.println(\u0026ldquo;Value: \u0026quot; + pair.getValue()); } }\nKey: Age Value: 30\nBạn có thể giới hạn kiểu tham số của Generic Class bằng extends. Bounded Type Parameters\nBạn có thể giới hạn kiểu tham số của Generic Class bằng extends.\nclass NumberBox { private T number;\npublic void setNumber(T number) { this.number = number; } public T getNumber() { return number; } }\npublic class Main { public static void main(String[] args) { NumberBox intBox = new NumberBox\u0026lt;\u0026gt;(); intBox.setNumber(100); System.out.println(\u0026ldquo;Integer: \u0026quot; + intBox.getNumber());\nNumberBox\u0026lt;Double\u0026gt; doubleBox = new NumberBox\u0026lt;\u0026gt;(); doubleBox.setNumber(10.5); System.out.println(\u0026quot;Double: \u0026quot; + doubleBox.getNumber()); // NumberBox\u0026lt;String\u0026gt; stringBox = new NumberBox\u0026lt;\u0026gt;(); // Lỗi compile-time } }\nInteger: 100 Double: 10.5\ngiới hạn T chỉ có thể là Number hoặc các lớp con của Number như Integer, Double,\u0026hellip; 4. Generic Method Generic Method là phương thức cho phép sử dụng kiểu dữ liệu tổng quát (Generic) thay vì kiểu dữ liệu cố định. Kiểu dữ liệu tổng quát này được định nghĩa khi phương thức được gọi.\nCách khai báo Generic Method\npublic ReturnType methodName(T parameter) { // Thân phương thức }\n: Khai báo một tham số kiểu dữ liệu tổng quát (Generic Type). T parameter: Sử dụng kiểu dữ liệu Generic làm tham số. ReturnType: Phương thức có thể trả về kiểu T hoặc các kiểu khác. Ví dụ:\npublic class GenericMethodExample {\n// Generic method public static \u0026lt;T\u0026gt; void printArray(T[] array) { for (T item : array) { System.out.println(item); } } public static void main(String[] args) { String[] stringArray = { \u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Cherry\u0026quot; }; Integer[] intArray = { 1, 2, 3 }; // Gọi phương thức generic printArray(stringArray); printArray(intArray); } }\nApple Banana Cherry 1 2 3\nPhương thức printArray có thể in mọi kiểu dữ liệu (String, Integer,\u0026hellip;) nhờ sử dụng T. Phương thức generic với giá trị trả về\npublic class GenericReturnTypeExample {\n// Generic method public static \u0026lt;T\u0026gt; T getFirstElement(T[] array) { if (array.length \u0026gt; 0) { return array[0]; } return null; // Trả về null nếu mảng rỗng } public static void main(String[] args) { String[] stringArray = { \u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Cherry\u0026quot; }; Integer[] intArray = { 10, 20, 30 }; System.out.println(\u0026quot;First string: \u0026quot; + getFirstElement(stringArray)); System.out.println(\u0026quot;First integer: \u0026quot; + getFirstElement(intArray)); } }\nFirst string: Apple First integer: 10\nGeneric Method getFirstElement trả về giá trị kiểu dữ liệu của mảng được truyền vào. Bounded Type Parameters in Generic Method\nSử dụng từ khóa extends để giới hạn kiểu dữ liệu tổng quát.\npublic class BoundedGenericMethodExample {\n// Generic method với kiểu giới hạn public static double sum(T a, T b) { return a.doubleValue() + b.doubleValue(); }\npublic static void main(String[] args) { System.out.println(\u0026quot;Sum of 10 and 20: \u0026quot; + sum(10, 20)); System.out.println(\u0026quot;Sum of 3.5 and 4.5: \u0026quot; + sum(3.5, 4.5)); // sum(\u0026quot;Hello\u0026quot;, \u0026quot;World\u0026quot;); // Lỗi compile-time } }\nSum of 10 and 20: 30.0 Sum of 3.5 and 4.5: 8.0\n: Giới hạn kiểu T chỉ cho phép Number hoặc các lớp con (như Integer, Double). Generic Method trong lớp không Generic\nBạn có thể định nghĩa phương thức generic trong một lớp không generic. public class NonGenericClass {\n//Phương thức generic trong lớp không generic public static void printItem(T item) { System.out.println(\u0026ldquo;Item: \u0026quot; + item); }\npublic static void main(String[] args) { printItem(\u0026quot;Hello\u0026quot;); printItem(123); } }\nItem: Hello Item: 123\nWildcards trong Generic Method\nDùng wildcard ? để viết phương thức generic linh hoạt hơn.\nimport java.util.List;\npublic class WildcardExample {\n// Sử dụng wildcard public static void printList(List\u0026lt;?\u0026gt; list) { for (Object item : list) { System.out.println(item); } } public static void main(String[] args) { List\u0026lt;String\u0026gt; stringList = List.of(\u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;); List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); printList(stringList); printList(intList); } }\nApple Banana 1 2 3\nWildcard ?: Cho phép sử dụng danh sách bất kỳ kiểu dữ liệu nào. 5. Wildcards (?) Trong Generics của Java, ký tự đại diện (Wildcard) ? được sử dụng để biểu thị một kiểu dữ liệu chưa biết. Nó giúp Generic trở nên linh hoạt hơn, đặc biệt khi làm việc với các loại dữ liệu không xác định chính xác.\nUnbounded Wildcard (?) Sử dụng khi kiểu dữ liệu có thể là bất kỳ loại nào. Cú pháp: ? import java.util.List; public class UnboundedWildcardExample { public static void printList(List list) { for (Object item : list) { System.out.println(item); } }\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; stringList = List.of(\u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;); List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); printList(stringList); printList(intList); } }\nApple Banana 1 2 3\nList cho phép truyền vào bất kỳ kiểu nào. Trong thân phương thức, bạn chỉ có thể sử dụng các thao tác được hỗ trợ với Object vì không biết chính xác kiểu của danh sách. 2. Upper Bounded Wildcard (\u0026lt;? extends T\u0026gt;) Giới hạn kiểu dữ liệu là một lớp cụ thể hoặc các lớp con của nó. Cú pháp: \u0026lt;? extends T\u0026gt; import java.util.List;\npublic class UpperBoundedWildcardExample { public static double sumNumbers(List\u0026lt;? extends Number\u0026gt; list) { double sum = 0.0; for (Number num : list) { sum += num.doubleValue(); } return sum; }\npublic static void main(String[] args) { List\u0026lt;Integer\u0026gt; integers = List.of(1, 2, 3); List\u0026lt;Double\u0026gt; doubles = List.of(1.5, 2.5, 3.5); System.out.println(\u0026quot;Sum of integers: \u0026quot; + sumNumbers(integers)); System.out.println(\u0026quot;Sum of doubles: \u0026quot; + sumNumbers(doubles)); } }\nSum of integers: 6.0 Sum of doubles: 7.5\nKhi không cần biết hay kiểm soát kiểu dữ liệu cụ thể. Ví dụ: In danh sách bất kỳ. 5. Lưu ý khi sử dụng Wildcards Không thể thêm giá trị ngoài null khi dùng ? hoặc \u0026lt;? extends T\u0026gt;. Dùng ? khi làm việc với dữ liệu mà chỉ cần truy cập, không cần thay đổi. Wildcards làm mã tổng quát hơn, nhưng cũng có thể làm giảm an toàn kiểu nếu dùng không cẩn thận. Wildcards là công cụ mạnh mẽ để làm cho Generics linh hoạt và mạnh mẽ hơn trong Java 6. Các tham số kiểu trong Generics T (Type): Đại diện cho một kiểu bất kỳ. Dùng phổ biến trong các lớp, phương thức, hoặc interface tổng quát.\nE (Element): Đại diện cho phần tử. Thường sử dụng trong các cấu trúc dữ liệu như danh sách hoặc tập hợp.\nK (Key): Đại diện cho khóa trong cấu trúc cặp giá trị, ví dụ như Map.\nV (Value): Đại diện cho giá trị tương ứng với một khóa, sử dụng với cặp K-V.\nN (Number): Đại diện cho kiểu số như Integer, Double, hoặc Float.\n? (Wildcard): Đại diện cho một kiểu chưa biết, giúp làm việc với các đối tượng có kiểu không xác định cụ thể.\nBounded Type Parameters (Giới hạn kiểu):\n: Giới hạn T là Class hoặc các lớp con. : Giới hạn T là một interface cụ thể hoặc lớp triển khai interface đó. 7. Bảng So Sánh List, List, List, List, List image.png\nKết bài Như vậy, chúng ta đã cùng nhau tìm hiểu về Generics trong Java, dù ban đầu việc làm quen với Generics có thể gây đôi chút khó khăn, nhưng với sự luyện tập và áp dụng thường xuyên, bạn sẽ thấy sự khác biệt rõ ràng trong cách quản lý kiểu dữ liệu và tối ưu hóa hiệu năng mã nguồn của mình. Hãy bắt đầu từ những ứng dụng nhỏ, từng bước triển khai Generics vào các bài toán thực tế, và biến chúng thành một phần không thể thiếu trong tư duy lập trình của bạn. Làm chủ Generics chính là một bước đi vững chắc để trở thành một lập trình viên Java chuyên nghiệp\n","date":"0001-01-01T00:00:00Z","permalink":"https://bao2482003.github.io/22DTHC5-6_BaoDG_MBT/posts/java-generics/","tags":null,"title":""}]